# 09장 람다 라이브러리

<details><summary>Table of Contents</summary>

-   09-1 람다 라이브러리 소개 [:link:](#09-1-람다-라이브러리-소개)
    -   ramda 라이브러리 [:link:](#ramda-라이브러리)
    -   실습 프로젝트 구성 [:link:](#실습-프로젝트-구성)
    -   ramda 패키지 불러오기 [:link:](#ramda-패키지-불러오기)
-   09-2 람다 기본 사용법 [:link:](#09-2-람다-기본-사용법)
    -   R.range 함수 [:link:](#rrange-함수)
    -   R.tap 디버깅용 함수 [:link:](#rtap-디버깅용-함수)
    -   R.pipe 함수 [:link:](#rpipe-함수)
    -   포인트가 없는 함수 [:link:](#포인트가-없는-함수)
    -   자동 커리 이해하기 [:link:](#자동-커리-이해하기)
    -   R.curryN 함수 [:link:](#rcurryn-함수)
    -   순수 함수 [:link:](#순수-함수)
-   09-3 배열에 담긴 수 다루기 [:link:](#09-3-배열에-담긴-수-다루기)
    -   선언형 프로그래밍 [:link:](#선언형-프로그래밍)
    -   사칙 연산 함수 [:link:](#사칙-연산-함수)
    -   R.addIndex 함수 [:link:](#raddindex-함수)
    -   R.flip 함수 [:link:](#rflip-함수)
    -   사칙 연산 함수들의 조합 [:link:](#사칙-연산-함수들의-조합)
    -   2차 방정식의 해 구현 [:link:](#2차-방정식의-해-구현)
-   09-4 서술자와 조건 연산 [:link:](#09-4-서술자와-조건-연산)
    -   서술자 [:link:](#서술자)
    -   수의 크기를 판단하는 서술자 [:link:](#수의-크기를-판단하는-서술자)
    -   R.allPass 로직 함수 [:link:](#rallpass-로직-함수)
    -   R.not 함수 [:link:](#rnot-함수)
    -   R.ifElse 함수 [:link:](#rifelse-함수)
-   09-5 문자열 다루기 [:link:](#09-5-문자열-다루기)
    -   문자열 앞뒤의 백색 문자 자르기 [:link:](#문자열-앞뒤의-백색-문자-자르기)
    -   대소문자 전환 [:link:](#대소문자-전환)
    -   구분자를 사용해 문자열을 배열로 변환 [:link:](#구분자를-사용해-문자열을-배열로-변환)
    -   toCamelCase 함수 만들기 [:link:](#tocamelcase-함수-만들기)
-   09-6 chance 패키지로 객체 만들기 [:link:](#09-6-chance-패키지로-객체-만들기)
    -   ICoordinates 타입 객체 만들기 [:link:](#icoordinates-타입-객체-만들기)
    -   ILocation 타입 객체 만들기 [:link:](#ilocation-타입-객체-만들기)
    -   IPerson 타입 객체 만들기 [:link:](#iperson-타입-객체-만들기)
-   09-7 렌즈를 활용한 객체의 속성 다루기 [:link:](#09-7-렌즈를-활용한-객체의-속성-다루기)
    -   렌즈란? [:link:](#렌즈란)
    -   R.prop과 R.assoc 함수 [:link:](#rprop과-rassoc-함수)
    -   R.lens 함수 [:link:](#rlens-함수)
    -   R.view, R.set, R.over 함수 [:link:](#rview-rset-rover-함수)
    -   R.lensPath 함수 [:link:](#rlenspath-함수)
-   09-8 객체 다루기 [:link:](#09-8-객체-다루기)
    -   R.toPairs와 R.fromPairs 함수 [:link:](#rtopairs와-rfrompairs-함수)
    -   R.keys와 R.values 함수 [:link:](#rkeys와-rvalues-함수)
    -   R.zipObj 함수 [:link:](#rzipobj-함수)
    -   R.mergeLeft와 R.mergeRight 함수 [:link:](#rmergeleft와-rmergeright-함수)
    -   R.mergeDeepLeft와 R.mergeDeepRight 함수 [:link:](#rmergedeepleft와-rmergedeepright-함수)
-   09-9 배열 다루기 [:link:](#09-9-배열-다루기)
    -   R.prepend와 R.append 함수 [:link:](#rprepend와-rappend-함수)
    -   R.flatten 함수 [:link:](#rflatten-함수)
    -   R.unnest 함수 [:link:](#runnest-함수)
    -   R.sort 함수 [:link:](#rsort-함수)
    -   R.sortBy 함수 [:link:](#rsortby-함수)
    -   R.sortWith 함수 [:link:](#rsortwith-함수)
-   09-10 조합 논리 이해하기 [:link:](#09-10-조합-논리-이해하기)

</details>

## 09-1 람다 라이브러리 소개

### ramda 라이브러리

`ramda` 패키지는 `compose`나 `pipe`를 사용하는 **함수 조합**을 쉽게 사용하도록 설계된 라이브러리다.<br/>
자바스크립트 오픈소스 라이브러리인 `ramda`는 아래와 같은 특징이 있다.<br/>

1. Typescript 언어와 100% 호환된다.
2. `compose`와 `pipe` 함수를 제공한다.
3. 자동 커리 기능을 제공한다.
4. 포인트가 없는 고차 도움 함수를 제공한다.
5. 조합 논리 함수를 일부 제공한다.
6. 하스켈 렌즈 라이브러리의 기능을 일부 제공한다.
7. 자바스크립트 표준 모나드 규격과 호환된다.

`ramda` 패키지는 많은 도움 함수를 제공한다.<br/>
이 도움 함수들의 문서는 아래의 두 사이트에서 찾을 수 있다.<br/>

> [https://ramdajs.com/docs/](https://ramdajs.com/docs/) : 함수를 알파벳 순서로 분류<br/>[https://devdocs.io/ramda/](https://devdocs.io/ramda/) : 함수를 기능 위주로 분류<br/>

0.26.1버전 기준의 `ramda` 패키지가 제공하는 함수 구분은 아래와 같다.<br/>

|      구분       | 내용                                                                                        |
| :-------------: | :------------------------------------------------------------------------------------------ |
| 함수 (Function) | `R.compose`, `R.pipe`, `R.curry` 등 52개의 함수                                             |
|  리스트 (List)  | 배열을 대상으로 하는 `R.map`, `R.filter`, `R.reduce` 등 87개 함수                           |
|  로직 (Logic)   | `R.not`, `R.or`, `R.cond` 등 불리언 로직 관련 17개 함수                                     |
|   수학 (Math)   | `R.add`, `R.subtract`, `R.multiply`, `R.divide` 등 수 관련 13개 함수                        |
|  객체 (Object)  | `R.prop`, `R.lens` 등 객체와 렌즈 관련 49개 함수                                            |
| 관계 (Relation) | `R.lt`, `R.lte`, `R.gt`, `R.gte` 등 두 값의 관계를 파악하게 하는 25개 함수                  |
| 문자열 (String) | `R.match`, `R.replace`, `R.split` 등 문자열을 대상으로 정규식 등을 할 수 있게 하는 8개 함수 |
|   타입 (Type)   | `R.is`, `R.isNil`, `R.type` 등 대상의 타입을 파악하게 하는 4개 함수                         |

### 실습 프로젝트 구성

프로젝트를 진행할 폴더를 만들고 해당 폴더로 이동한 후 아래의 명령어를 실행한다.<br/>

```shell
> npm init --y
> npm i -D typescript ts-node @types/node
> mkdir src
```

이어서 아래의 명령어로 `ramda` 패키지를 설치한다.<br/>

```shell
> npm i -S ramda
> npm i -D @types/ramda
```

또한 가짜 데이터를 만들어 주는 `chance` 패키지를 설치한다.<br/>

```shell
> npm i -S chance
> npm i -D @types/chance
```

마지막으로 `package.json`이 있는 경로에 아래와 같이 `tsconfig.json` 파일을 생성한다.<br/>

```json
{
    "compilerOptions": {
        "module": "CommonJS",
        "esModuleInterop": true,
        "target": "es5",
        "moduleResolution": "node",
        "outDir": "dist",
        "baseUrl": ".",
        "sourceMap": true,
        "downlevelIteration": true,
        "noImplicitAny": false,
        "paths": {
            "*": ["node_modules/*"]
        }
    },
    "include": ["src/**/*"]
}
```

`ramda` 패키지는 Javascript를 대상으로 설계되었기 때문이다.<br/>
따라서 Typescript는 `any` 타입을 완전히 Javascript 적으로 해석애야 한다.<br/>
그러므로 `tsconfig.json`의 `noImplicitAny` 속성값을 `false`로 지정한다.<br/>

### ramda 패키지 불러오기

보통 Typescript 소스코드에서는 `ramda` 패키지는 아래와 같이 불러온다.<br/>

```typescript
import * as R from "ramda";
```

`R` 이라는 심벌로 `ramda` 패키지를 사용해 `R.함수명` 형식으로 함수들을 사용한다.<br/>
프로젝트 배포 시 크기를 줄이기 위해서 패키지를 `* as R`과 같이 불러온 것을 아래와 같이 변경하는 것이 좋다.<br/>

```typescript
import { range } from "ramda";
```

`import * as R`과 같이 사용하면 `ramda` 패키지 중 사용하지 않는 함수들도 패키징되게 된다.<br/>
`import { range }`와 같이 사용하면 `range` 함수만 패키징 되므로 패키징된 코드의 크기를 줄일 수 있다.<br/>

[[🔝위로가기]](#09장-람다-라이브러리)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 09-2 람다 기본 사용법

### R.range 함수

`R.range` 함수는 아래의 형식으로 사용하며 `[최솟값, 최솟값 + 1, ..., 최댓값 - 1]` 형태의 배열을 생성한다.<br/>

```typescript
import * as R from "ramda";

console.log(R.range(1, 9 + 1)); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
```

위의 코드는 `R.range` 함수를 이용해 1부터 9까지 연속된 숫자 배열을 생성하는 예시다.<br/>

### R.tap 디버깅용 함수

복잡한 함수를 간단하게 구현하려면 **함수 조합**을 이용한다.<br/>
이때 단계별로 값이 어떻게 변하는지 파악하면서 코드를 작성해야한다.<br/>
이때 `ramda`가 제공하는 `R.tap` 함수는 **2차 고차 함수** 형태로 현재 값을 파악할 수 있게 해준다.<br/>

```typescript
R.tap(콜백 함수)(배열)
```

아래 코드는 `R.range` 함수로 생성한 배열의 내용을 `R.tap` 함수를 사용해 화면에 출력하는 예시다.<br/>

```typescript
import * as R from "ramda";

const numbers: number[] = R.range(1, 9 + 1);
R.tap((n) => console.log(n))(numbers); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
```

`R.tap` 함수는 설계대로 **합수 조합**이 동작하지 않을 때 **논리 오류를 찾기 위해 사용**한다.<br/>

### R.pipe 함수

`ramda`는 앞에서 설명한 `compose`와 `pipe` 함수를 `R.compose`와 `R.pipe` 형태로 제공한다.<br/>

```typescript
import * as R from "ramda";

const array: number[] = R.range(1, 10);
R.pipe(R.tap((n) => console.log(n)))(array); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
```

`R.compose`보다 `R.pipe` 함수가 코드를 이해하기 편하며 두 함수 모두 **함수 조합**을 위해 사용된다.<br/>

### 포인트가 없는 함수

`ramda` 라이브러리는 200개가 넘는 함수를 제공하지만 대부분은 **2차 고차 함수** 형태로 구현되어 있다.<br/>
**2차 고차 함수**는 **포인트가 없는 함수** 형태로 사용할 수 있다.<br/>

```typescript
import * as R from "ramda";

export const dump = R.pipe(R.tap((n) => console.log(n)));
```

위의 `dump` 함수는 **포인트가 없는 함수**의 전형적인 모습이다.<br/>
아래와 같은 테스트 코드를 작성해 실행하면 실제 함수로 동작한다.<br/>

```typescript
import * as R from "ramda";
import { dump } from "./Dump";

dump(R.range(1, 10)); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
```

`ramda` 라이브러리는 Typescript를 고려해 만든 라이브러리가 아니다.<br/>
따라서 **포인트가 없는 함수**를 아래 같이 일반 화살표 함수로 만들면 오류가 발생한다.<br/>

```typescript
const dumpError = <T>(array: T[]): T[] =>
    R.pipe(R.tap((n) => console.log(n)))(array);
```

-   **포인트가 없는 함수**를 화살표 함수로 만들었을 경우 발생한 오류

<img src="./images/1.png" width="500" height="auto">

이 오류를 해결하기 위해서는 **타입 단언**을 사용해야 한다.<br/>

```typescript
export const dumpArrow = <T>(array: T[]): T[] =>
    R.pipe(R.tap((n) => console.log(n)))(array) as T[];
```

`as T[]`처럼 타입 단언을 사용해 `R.pipe(...)(array)`가 반환하는 타입을 `T[]`로 바꾸어준다.<br/>

```typescript
import * as R from "ramda";
import { dumpArrow } from "./Dump";

dumpArrow(R.range(1, 10)); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
```

**포인트가 없는 함수**인 `dump` 함수와 동일하게 `dumpArraow` 함수가 작동하는 것을 볼 수 있다.<br/>
동일하게 작동하지만 **포인트가 없는 함수**를 만드는 것이 불필요한 오류를 만나지 않는 방법이다.<br/>

### 자동 커리 이해하기

`ramda`의 함수들은 `R.add(1, 2)`처럼 매개변수가 두 개인 **일반 함수**처럼 사용할 수 있다.<br/>
또한 `R.add(1)(2)`와 같이 **2차 고차 함수**로 사용할 수도 있다.<br/>

```typescript
import * as R from "ramda";

console.log(R.add(1, 2)); // 3
console.log(R.add(1)(2)); // 3
```

`ramda` 라이브러리에서는 이와 같이 기능을 **자동 커리**라고 한다.<br/>

### R.curryN 함수

`ramda`의 함수들은 **자동 커리** 방식으로 동작할 수 있도록 매개변수의 개수가 모두 정해져있다.<br/>
따라서 아래의 `sum` 함수처럼 **가변 인수** 형태로 구현된 함수는 없다.<br/>

```typescript
export const sum = (...numbers: number[]): number =>
    numbers.reduce((result: number, sum: number) => result + sum, 0);
```

`sum`과 같은 함수를 **N차 고차 함수**로 만들고 싶다면 `R.curryN` 함수를 사용하면 된다.<br/>
`R.curryN` 함수는 `N`개의 매개변수를 가진 **1차 함수**를 `N`개의 커리를 갖는 **N차 고차 함수**로 만들 어준다.<br/>

```typescript
R.curryN(N, 함수);
```

아래의 코드는 앞의 `sum` 함수에 `R.curryN`을 적용해 **4차 고차 함수**로 만든 예시다.<br/>

```typescript
import * as R from "ramda";
import { sum } from "./Sum";

export const curriedSum = R.curryN(4, sum);
```

아래와 같은 테스트 코드를 작성해 **4차 고차 함수**로 만든 `curriedSum` 함수 동작을 확인한다.<br/>

```typescript
import { curriedSum } from "./CurriedSum";

console.log(curriedSum()); // [Function]
console.log(curriedSum(1)); // [Function]
console.log(curriedSum(1)(2)); // [Function]
console.log(curriedSum(1)(2)(3)); // [Function]
console.log(curriedSum(1)(2)(3)(4)); // 10
```

`curriedSum` 함수가 **4차 고차 함수**이기 때문에 `curriedSum(1)(2)(3)(4)`만 값을 반환한다.<br/>
반면에 나머지는 **함수 호출 연산자**가 **차수**를 충족하지 못하므로 모두 **부분 함수를 반환**한다.<br/>

### 순수 함수

`ramda` 라이브러리는 **순수 함수**를 고려해 설계되었다.<br/>
따라서 `ramda` 라이브러리의 함수들은 **입력 변수의 상태를 변화시키지 않고 새로운 값을 반환**한다.<br/>
아래 코드의 `resultArray`를 만드는 `originalArray`는 자신의 모습을 그대로 유지한다.<br/>

```typescript
import * as R from "ramda";

const originalArray: number[] = [1, 2, 3];
const resultArray = R.pipe(R.map(R.add(1)))(originalArray);

console.log(originalArray, resultArray); // [ 1, 2, 3 ] [ 2, 3, 4 ]
```

`ramda` 라이브러리의 모든 함수는 이와 같이 **순수 함수** 형태로 동작한다.<br/>

[[🔝위로가기]](#09장-람다-라이브러리)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 09-3 배열에 담긴 수 다루기

### 선언형 프로그래밍

보통 **함수형 프로그래밍**은 **선언형 프로그래밍** 방식으로 코드를 작성한다.<br/>
**선언형 프로그래밍**에서 모든 입력 데이터는 단순 데이터보다 **배열** 형태를 주로 사용한다.<br/>

-   입력 데이터를 단순 데이터로 사용한 예시

```typescript
import * as R from "ramda";

const value = 1;
const newValue = R.inc(value);
```

-   입력 데이터를 **배열**로 사용한 예시

```typescript
import * as R from "ramda";

const value = 1;
const newArray = R.pipe(R.map(R.inc))([value]);
```

아래의 코드는 `R.tap` 디버깅 함수를 사용해 `R.map` 실행 전과 후의 배열의 값을 출력한다.<br/>

```typescript
import * as R from "ramda";

const numbers: number[] = R.range(1, 9 + 1);

const incNumber = R.pipe(
    R.tap((a) => console.log("Before inc:", a)),
    // Before inc: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
    R.map(R.inc),
    R.tap((a) => console.log("After inc:", a))
    // After inc: [ 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
);

const newNumbers = incNumber(numbers);
console.log(newNumbers); // [ 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
```

`R.pipe`안에서는 `console.log`를 직접 사용할 수 없으므로 `R.tap` 함수를 사용해야한다.<br/>
`ramda` 라이브러리로 어떤 로직을 구현할 때 이런 방식으로 디버깅을 진행한다.<br/>

### 사칙 연산 함수

`ramda`는 다음과 같은 사칙 연산 관련 함수들을 제공한다.<br/>

```typescript
R.add(a: number)(b: number); // a + b
R.subtract(a: number)(b: number); // a - b
R.multiply(a: number)(b: number); // a * b
R.divide(a: number)(b: number); // a / b
```

앞의 `R.inc`는 `R.add(1)`과 동일한 기능을 한다.<br/>
아래 코드는 포인트가 있는 함수 형태로 `R.add`를 사용해 `inc`라는 함수를 만든 예시다.<br/>

```typescript
const inc = (b: number): number => R.add(1)(b);
```

이 코드를 **포인트가 없는 함수**로 구현하면 아래와 같다.<br/>

```typescript
const inc = R.add(1);
```

이렇게 만든 `inc` 함수를 `R.map` 함수에 포인트가 있는 형태로 사용하면 아래와 같다.<br/>

```typescript
const inc = (b: number): number => R.add(1)(b);
R.map((n: number) => inc(n));
```

이 구조는 `R.map(콜백 함수)`의 콜백 함수를 익명 함수로 구현한 구조다.<br/>
현재 `inc` 함수는 그 자체가 콜백 함수로 사용될 수 있다.<br/>
따라서 앞의 코드는 아래와 같이 간결하게 표현할 수 있다.<br/>

```typescript
const inc = (b: number): number => R.add(1)(b);
R.map(inc);
```

또한 `inc` 함수는 `R.add(1)`이므로 아래와 같이 작성해도 동일하게 동작한다.<br/>

```typescript
R.map(R.add(1));
```

아래 코드는 이러한 내용을 바탕으로 작성한 코드다.<br/>

```typescript
import * as R from "ramda";

const incNumber = R.pipe(
    R.map(R.add(1)),
    R.tap((a) => console.log("After add(1):", a))
    // After add(1): [ 2, 3, 4, 5, 6, 7, 8, 9, 10 ]
);

const newNumbers = incNumber(R.range(1, 9 + 1));
```

**포인트가 없는 함수**와 **콜백 함수**를 **익명 함수 형태로만 구현하는 것이 아니라는 점**이 중요하다.<br/>

### R.addIndex 함수

`Array.map`은 두 번째 매개변수로 `index`를 제공하지만 `R.map`은 `index`를 제공하지 않는다.<br/>
따라서 `R.map`이 `Array.map`과 같이 동작하려면 `R.addIndex` 함수를 사용해야 한다.<br/>

```typescript
const indexedMap = R.addIndex(R.map);
```

위와 같이 `R.addIndex` 함수를 사용해 `R.map`을 `index`를 제공하는 새로운 함수를 만들어야 한다.<br/>
이렇게 만들어진 `indexedMap`은 두 번째 매개변수로 `index`를 제공한다.<br/>

```typescript
indexedMap((value: number, index: number) => R.add(number)(index));
```

만약 `indexedMap`의 콜백 함수가 위와 같다면 아래 처럼 더 간결하게 작성할 수 있다.<br/>

```typescript
indexedMap(R.add);
```

아래의 코드는 위의 내용을 바탕으로 구현한 예시다.<br/>

```typescript
import * as R from "ramda";

const addIndex = R.pipe(
    R.addIndex(R.map)(R.add),
    R.tap((a) => console.log(a))
    // [ 1, 3, 5, 7, 9, 11, 13, 15, 17 ]
);

const newNumbers = addIndex(R.range(1, 9 + 1));
```

`R.add`만 사용해도 `R.add(value)(index)`와 동일하게 동작하는 것을 볼 수 있다.<br/>

### R.flip 함수

`R.add`, `R.multiply`와 달리 `R.subtract`와 `R.divide`는 매개변수의 순서에 따라 값이 달라진다.<br/>
`R.subtract`는 첫 번째 매개변수에서 두 번째 매개변수 값을 빼는 형태로 구현되어있다.<br/>

```typescript
import * as R from "ramda";

const subtract = (a) => (b) => a - b;

const subtractFrom10 = subtract(10);

const newArray = R.pipe(
    R.map(subtractFrom10),
    R.tap((a) => console.log(a))
    // 9, 8, 7, 6, 5, 4, 3, 2, 1
)(R.range(1, 9 + 1));
```

두 번째 매개변수에서 첫 번째 매개변수 값을 빼는 형태로 구현을 하려면 `R.filp`을 사용하면 된다.<br/>
`R.flip`은 `R.subtract`와 같은 **2차 고차 함수**의 매개변수 순서를 바꾸어준다.<br/>
`R.filp`을 이용해 `b - a`와 같이 동작하는 함수는 아래와 같이 작성할 수 있다.<br/>

```typescript
const reverseSubtract = R.flip(R.subtract);
```

앞의 `subtractFrom10`은 배열의 아이템을 대상으로 `10 - value` 연산을 수행했다.<br/>
아래의 `reverseSubtract`는 배열의 아이템을 대상으로 `value - 10`의 연산을 수행한다.<br/>

```typescript
import * as R from "ramda";

const reverseSubtract = R.flip(R.subtract);

const newArray = R.pipe(
    R.map(reverseSubtract(10)),
    R.tap((a) => console.log(a))
    // [ -9, -8, -7, -6, -5, -4, -3, -2, -1 ]
)(R.range(1, 9 + 1));
```

위와 같이 `R.flip` 함수를 이용해 **2차 고차 함수**의 매개변수를 반대로 사용할 수 있다.<br/>

### 사칙 연산 함수들의 조합

수핵에서는 아래 형태의 공식을 자주 볼 수 있다.<br/>

```text
f(x) = ax² + bx + c
```

이 공식을 Typescript로 구현하면 아래와 같다.<br/>

```typescript
type NumberToNumberFunc = (number) => number;

export const f = (a: number, b: number, c: number): NumberToNumberFunc => (
    x: number
): number => a * x ** 2 + b * x + c;
```

위의 `f` 함수를 `ramda`를 이용해 구현하면 아래와 같은 형태가 된다.<br/>

```typescript
import * as R from "ramda";

const exp = (N: number) => (x: number): number => x ** N;
const square = exp(2);

type NumberToNumberFunc = (number) => number;

export const f = (a: number, b: number, c: number): NumberToNumberFunc => (
    x: number
): number => R.add(a * square(x) + b * x, c);
```

`R.add` 함수는 **2차 고차 함수**이므로 `R.add(a * square(x) + b * x, c)` 같은 형태가 만들어 진다.<br/>
`f` 함수의 곱셈 부분을 `R.multiply`로 대체하면 아래와 같이 바뀐다.<br/>

```typescript
export const f = (a: number, b: number, c: number): NumberToNumberFunc => (
    x: number
): number => R.add(R.multiply(a)(square(x)) + R.multiply(b)(x), c);
```

또한 `+` 연산자를 `R.add`로 대체하면 최종적으로 아래 형태의 함수가 만들어진다.<br/>

```typescript
export const f = (a: number, b: number, c: number): NumberToNumberFunc => (
    x: number
): number => R.add(R.add(R.multiply(a)(square(x)), R.multiply(b)(x)), c);

console.log(f(2, 2, 4)(2)); // 2 * 2² + 2 * 2 + 4 = 16
```

위와 같이 `f(2, 2, 4)(2)`와 같이 호출하면 `2 * 2² + 2 * 2 + 4`의 결과값인 `16`을 확인할 수 있다.<br/>

### 2차 방정식의 해 구현

수학에서 2차 방정식은 아래 조건을 만족하는 `x`를 구하는 것이다.<br/>

```text
ax² + bx + c = 0
```

만약 `a = 1`, `b = 2`, `c = 1`이라면 다음 인수 분해 공식이 성립된다.<br/>

```text
x² + 2x + 1 = (x + 1)²
```

아래 코드의 `quadratic` 함수는 일반적인 2차 함수에 `a = 1`, `b = 2`, `c = 1`을 대입한 1차 함수다.<br/>

```typescript
import { f, exp, square } from "./FRamda";

export const quadratic = f(1, 2, 1);
export { exp, square };
```

아래 코드는 `quadratic` 함수를 사용해 `1`부터 `10`까지 변수를 `x`에 대입한 결과를 얻는다.<br/>

```typescript
import * as R from "ramda";
import { quadratic } from "./Quadratic";

const input: number[] = R.range(1, 10 + 1);
const quadraticResult = R.pipe(
    R.map(quadratic),
    R.tap((a) => console.log(a))
    // [ 4, 9, 16, 25, 36, 49, 64, 81, 100, 121 ]
)(input);
```

아래 코드는 `(x + 1)²` 수식에 `1`부터 `10`까지의 수를 변수 `x`에 대입한 결과를 얻는다.<br/>

```typescript
import * as R from "ramda";
import { square } from "./Quadratic";

const input: number[] = R.range(1, 10 + 1);
const squareAfterInc = R.pipe(R.inc, square);

const squareResult = R.pipe(
    R.map(squareAfterInc),
    R.tap((a) => console.log(a))
    // [ 4, 9, 16, 25, 36, 49, 64, 81, 100, 121 ]
)(input);
```

`quadraticResult`의 결과와 `squareResult`의 결과가 동일하므로 공식이 맞다는 것을 증명한다.<br/>

[[🔝위로가기]](#09장-람다-라이브러리)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 09-4 서술자와 조건 연산

### 서술자

`Array.filter` 함수에서 사용되는 콜백함수는 `boolean` 타입을 반환해야한다.<br/>
함수형 프로그래밍에서 `boolean` 타입을 반환해 조건을 판단하는 함수를 **서술자**라고 한다.<br/>

```typescript
const filteredArray = [1, 2, 6, 7, 8].filter((number) => number > 5);
console.log(filteredArray); // [ 6, 7, 8 ]
```

위의 코드에서 `(number) => number > 5`과 같은 콜백함수가 **서술자**다.<br/>
값이 5보다 큰 조건을 만족하는 `6`, `7`, `8`을 담은 배열이 반환되는 것을 볼 수 있다.<br/>

### 수의 크기를 판단하는 서술자

`ramda`는 수를 비교해 `true`나 `false`를 반환하는 아래의 **서술자**들을 제공한다.<br/>

```typescript
R.lt(a)(b): boolean // a < b
R.lte(a)(b): boolean // a <= b
R.gt(a)(b): boolean // a > b
R.gte(a)(b): boolean // a >= b
```

이 함수들은 주로 `R.filter` 함수와 결합해 포인트가 없는 함수 형태로 사용된다.<br/>
아래 코드는 `3`보다 **크거나 같은** 수만 선택하는 작업을 `R.lte`를 사용해 구현한 예시다.<br/>

```typescript
import * as R from "ramda";

R.pipe(
    R.filter(R.lte(3)),
    R.tap((n) => console.log(n))
    // [ 3, 4, 5, 6, 7, 8, 9, 10 ]
)(R.range(1, 10 + 1));
```

`R.lte(3)`의미는 `3 <= x`이며 `R.filp(R.gte)(3)`과 같이 직관적으로 변경해 사용할 수도 있다.<br/>

```typescript
import * as R from "ramda";

R.pipe(
    R.filter(R.gt(6 + 1)),
    R.tap((n) => console.log(n))
    // [ 1, 2, 3, 4, 5, 6 ]
)(R.range(1, 10 + 1));
```

위 코드는 배열에서 `7`보다 작은 아이템만 선택하는 예시이며 `R.gt(6 + 1)`은 `x < 7`의 의미다.<br/>

```typescript
import * as R from "ramda";

R.pipe(
    R.filter(R.lte(3)),
    R.filter(R.gt(6 + 1)),
    R.tap((n) => console.log(n))
    // [ 3, 4, 5, 6 ]
)(R.range(1, 10 + 1));
```

위의 예시는 배열의 아이템 중 `3 <= x < 7` 범위에 있는 수만 선택하는 로직을 구현한 예시다.<br/>

### R.allPass 로직 함수

`R.lt` 처럼 `boolean` 타입의 값을 반환하는 함수들은 `R.allPass`와 `R.anyPass` 함수로 결합할 수 있다.<br/>

```typescript
R.allPass(서술자 배열) // 배열의 조건을 모두 만족하면 true
R.anyPass(서술자 배열) // 배열의 조건을 하나라도 만족하면 true
```

아래 코드는 `x`가 `min <= x < max` 조건을 만족하는지 `R.allPass` 함수를 사용해 확인한다.<br/>

```typescript
import * as R from "ramda";

type NumberToBooleanFunc = (n: number) => boolean;
export const selectRange = (min: number, max: number): NumberToBooleanFunc =>
    R.allPass([R.lte(min), R.gt(max)]);
```

작성한 `selectRange` 함수를 `R.filter`와 결합해 포인트가 없는 함수 형태로 사용한 예시다.<br/>

```typescript
import * as R from "ramda";
import { selectRange } from './SelectRange';

R.pipe(
    R.filter(selectRange(3, 6 + 1)),
    R.tap(n => console.log(n)); // [ 3, 4, 5, 6]
)(R.range(1, 10 + 1))
```

작성한 코드의 결과물은 `R.lte(3)`와 `R.gt(6 + 1)`을 사용한 예시와 동일하다.<br/>
앞의 예시는 `R.filter` 함수를 두 번 사용했지만 위의 예시는 한 번만 사용해 동작 속도가 더 빠를 것 이다.<br/>

### R.not 함수

`R.not`은 함수 이름 그대로 입력값이 `true`이면 `false`를 반환하고 `false`이면 `true`를 반환하는 함수다.<br/>

```typescript
import * as R from "ramda";
import { selectRange } from "./SelectRange";
export const notRange = (min: number, max: number) =>
    R.pipe(selectRange(min, max), R.not);
```

`selectRange`와 반대로 작용하는 함수는 `R.pipe`로 `R.not`을 `selectRange`와 조합해 구현할 수 있다.<br/>

```typescript
import * as R from "ramda";
import { notRange } from "./NotRange";

R.pipe(
    R.filter(notRange(3, 6 + 1)),
    R.tap((n) => console.log(n)) // [ 1, 2, 7, 8, 9, 10]
)(R.range(1, 10 + 1));
```

위의 코드의는 `selectRange`를 사용한 실행 결과와 정반대의 결과를 볼 수 있다.<br/>

### R.ifElse 함수

`R.ifElse` 함수는 세 가지 매개변수를 포함한다.<br/>

1. `true`/`false`를 반환하는 서술자
2. 선택자가 `true`를 반환할 때 실행할 함수
3. 선택자가 `false`를 반환할 때 실행할 함수

```typescript
R.ifElse(
    조건 서술자,
    true일 때 실행할 함수,
    false일 때 실행할 함수
)
```

아래 코드는 `R.ifElse`를 사용한 예시다.<br/>

```typescript
import * as R from "ramda";

const input: number[] = R.range(1, 10 + 1);
const halfValue = input[input.length / 2];

const subtractOrAdd = R.pipe(
    R.map(R.ifElse(R.lte(halfValue), R.inc, R.dec)),
    R.tap((a) => console.log(a))
    // [ 0, 1, 2, 3, 4, 7, 8, 9, 10, 11 ]
);
const result = subtractOrAdd(input);
```

`1`부터 `10`까지의 수에서 `halfValue`보다 작은 수는 `1` 감소시키고 같거나 큰 수는 `1` 증가시킨다.<br/>
`halfValue`보다 같거나 큰 수는 `R.inc` 함수가 적용되고 작은 수는 `R.dec` 함수가 적용된다.<br/>

[[🔝위로가기]](#09장-람다-라이브러리)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 09-5 문자열 다루기

### 문자열 앞뒤의 백색 문자 자르기

`R.trim` 함수는 문자열 앞뒤의 공백을 제거해 준다.<br/>

```typescript
import * as R from "ramda";

console.log(R.trim("\t hello \t")); // hello
```

`\t hello \t`에서 앞뒤의 `"\t"`과 `" "`이 제거된 것을 확인할 수 있다.<br/>

### 대소문자 전환

`R.toLower` 함수는 문자열에서 대문자를 모두 소문자로 전환해준다.<br/>

```typescript
import * as R from "ramda";

console.log(R.toLower("HELLO")); // hello
```

`R.toUpper` 함수는 반대로 소문자를 모두 대문자로 전환해준다.<br/>

```typescript
import * as R from "ramda";

console.log(R.toUpper("hello")); // HELLO
```

위와 같이 `R.toLower`와 `R.toUpper`를 사용해 대소문자를 전환할 수 있다.<br/>

### 구분자를 사용해 문자열을 배열로 변환

`R.split` 함수는 구분자를 사용해 문자열을 배열로 바꾸어준다.<br/>

```typescript
문자열 배열 = R.split(구분자)(문자열)
```

문자열 배열은 `R.join`을 사용해 문자열로 바꿀 수 있다.<br/>

```typescript
문자열 = R.join(구분자)(문자열 배열)
```

아래 코드는 `R.split` 함수를 이용해 공백을 구분자로 삼아 분리한 배열을 만든다.<br/>
또한 공백을 구분자로 삼아 분리한 배열을 `R.join` 함수로 문자열로 바꾼다.<br/>

```typescript
import * as R from "ramda";

const words: string[] = R.split(" ")("Hello world!, I'm Peter.");
console.log(words); // [ 'Hello', 'world!,', "I'm", 'Peter.' ]
console.log(R.join(" ")(words)); // Hello world!, I'm Peter.
```

공백을 구분자로 한 `R.split` 함수와 `R.join` 함수가 위와 같이 동작하는 것을 볼 수 있다.<br/>

### toCamelCase 함수 만들기

Typescript에서 문자열은 `readonly` 형태로만 사용할 수 있다.<br/>
따라서 `Hello world`를 `helloWorld`처럼 가공하려면 문자열을 **배열로 전환**해야 한다.<br/>
아래의 `toCamelCase` 함수는 임의의 문자열을 낙타 등 표기법으로 바꾸어 준다.<br/>

```typescript
import * as R from "ramda";

type StringToStringFunc = (string) => string;
export const toCamelCase = (delim: string): StringToStringFunc => {
    const makeFirstToCapital = (word: string) => {
        const characters = word.split("");

        return characters
            .map((c, index) => (index === 0 ? c.toUpperCase() : c))
            .join("");
    };
    const indexedMap = R.addIndex(R.map);
    return R.pipe(
        R.trim,
        R.split(delim),
        R.map(R.toLower),
        indexedMap((value: string, index: number) =>
            index > 0 ? makeFirstToCapital(value) : value
        ),
        R.join("")
    ) as StringToStringFunc;
};
```

`R.pipe`로 조합된 함수들은 아래의 기능을 한다.<br/>

1. 문자열의 앞뒤 공백을 제거한다.
2. `delim` 매개변수로 전달받은 문자열을 구분자로 삼아 배열로 전환한다.
3. 배열의 아이템을 모두 소문자로 변환한다.
4. 배열에서 두 번째 문자열부터 첫 문자만 대문자로 변경한다.
5. 배열을 문자열로 전환한다.

아래의 코드로 `toCamelCase` 함수를 테스트할 수 있다.<br/>

```typescript
import { toCamelCase } from "./ToCamelCase";

console.log(toCamelCase(" ")("Hello world")); // helloWorld
console.log(toCamelCase("_")("Hello_Albert_Einstein")); // helloAlbertEinstein
```

위와 같이 `Hello world`와 `Hello_Albert_Einstein`가 낙타 등 표기법으로 변환된 것을 볼 수 있다.<br/>

[[🔝위로가기]](#09장-람다-라이브러리)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 09-6 chance 패키지로 객체 만들기

### ICoordinates 타입 객체 만들기

`ICoordinates` 객체는 위도와 경도를 속성으로 하는 좌표를 표현한다.<br/>
`ICoordinates` 객체를 구현하기 위해 아래의 명령어로 필요한 파일을 생성한다.<br/>

```shell
> mkdir -p src/model/coordinates
> touch src/model/coordinates/ICoordinates.ts
> touch src/model/coordinates/makeICoordinates.ts
> touch src/model/coordinates/makeRandomICoordinates.ts
> touch src/model/coordinates/index.ts
```

위도와 경도를 속성으로 하는 좌표를 표현하는 객체의 타입인 `ICoordinates`을 구현한다.<br/>

-   `ICoordinates.ts`

```typescript
export type ICoordinates = {
    latitude: number;
    longitude: number;
};
```

작성한 `ICoordinates` 객체를 쉽게 만들어주는 `makeICoordinates` 함수를 구현한다.<br/>

-   `makeICoordinates.ts`

```typescript
import { ICoordinates } from "./ICoordinates";

export const makeICoordinates = (
    latitude: number,
    longitude: number
): ICoordinates => ({ latitude, longitude });
```

`chance` 패키지를 이용해 랜덤 값을 만들어주는 `makeRandomICoordinates` 함수를 구현한다.<br/>

-   `makeRandomICoordinates.ts`

```typescript
import Chance from "chance";
import { ICoordinates } from "./ICoordinates";
import { makeICoordinates } from "./makeICoordinates";

const c = new Chance();

export const makeRandomICoordinates = (): ICoordinates =>
    makeICoordinates(c.latitude(), c.longitude());
```

마지막으로 `src/model/coordinates` 폴더에서 아래 내용의 `index.ts`를 작성한다.<br/>

-   `index.ts`

```typescript
import { ICoordinates } from "./ICoordinates";
import { makeICoordinates } from "./makeICoordinates";
import { makeRandomICoordinates } from "./makeRandomICoordinates";

export { ICoordinates, makeICoordinates, makeRandomICoordinates };
```

`src` 폴더에 아래와 같은 내용으로 작성한 함수를 테스트할 수 있다.<br/>

```typescript
import { ICoordinates, makeRandomICoordinates } from "./model/coordinates/";

const coordinates: ICoordinates = makeRandomICoordinates();
console.log(coordinates); // { latitude: 42.72372, longitude: 21.19523 }
```

`makeRandomICoordinates` 함수를 호출하면 `ICoordinates` 타입의 데이터가 랜덤하게 생성된다.<br/>

### ILocation 타입 객체 만들기

`ILocation` 객체는 `ICoordinates` 타입 속성을 포함한다.<br/>
`ILocation` 객체를 구현하기 위해 아래의 명령어로 필요한 파일을 생성한다.<br/>

```shell
> mkdir -p src/model/location
> touch src/model/location/ILocation.ts
> touch src/model/location/makeILocation.ts
> touch src/model/location/makeRandomILocation.ts
> touch src/model/location/index.ts
```

어떤 사람의 주소는 대략 아래와 같이 표현할 수 있다.<br/>
`ILocation` 타입에서 `country`만 필수 속성이고 나머지는 모두 선택 속성으로 구현한다.<br/>

-   `ILocation.ts`

```typescript
import { ICoordinates } from "../coordinates";

export type ILocation = {
    country: string;
    city?: string;
    address?: string;
    coordinates?: ICoordinates;
};
```

작성한 `ILocation` 객체를 생성하는 `makeILocation` 함수를 구현한다.<br/>

-   `makeILocation.ts`

```typescript
import { ILocation } from "./ILocation";
import { ICoordinates } from "../coordinates";

export const makeILocation = (
    country: string,
    city?: string,
    address?: string,
    coordinates?: ICoordinates
): ILocation => ({ country, city, address, coordinates });
```

`chance` 패키지를 이용해 `ILocation`의 데이터를 생성하는 `makeRandomILocation` 함수를 구현한다.<br/>

```typescript
import { ILocation } from "./ILocation";
import { makeILocation } from "./makeILocation";
import { makeRandomICoordinates } from "../coordinates";
import Chance from "chance";

const c = new Chance();

export const makeRandomILocation = (): ILocation =>
    makeILocation(c.country(), c.city(), c.address(), makeRandomICoordinates());
```

마지막으로 `src/model/location` 폴더에서 아래 내용의 `index.ts`를 작성한다.<br/>

-   `index.ts`

```typescript
import { ILocation } from "./ILocation";
import { makeILocation } from "./makeILocation";
import { makeRandomILocation } from "./makeRandomILocation";

export { ILocation, makeILocation, makeRandomILocation };
```

`src` 폴더에 아래와 같은 내용으로 작성한 함수를 테스트할 수 있다.<br/>

```typescript
import { makeRandomILocation, ILocation } from "./model/location";

const location: ILocation = makeRandomILocation();
console.log(location);
// {
//   country: 'MH',
//   city: 'Ucoopafov',
//   address: '1673 Kocaz Place',
//   coordinates: { latitude: 73.15148, longitude: -87.6596 }
// }
```

`makeRandomILocation` 함수를 호출하면 `ILocation` 타입의 데이터가 랜덤하게 생성된다.<br/>

### IPerson 타입 객체 만들기

`IPerson` 타입을 구현하기 위해 아래 명령어로 관련 파일을 생성한다.<br/>

```shell
> mkdir -p src/model/person
> touch src/model/person/IPerson.ts
> touch src/model/person/makeIPerson.ts
> touch src/model/person/makeRandomIPerson.ts
> touch src/model/person/index.ts
```

아래와 같이 `IPerson` 타입을 선언하고 `name`과 `age`속성을 제외하고 모두 선택 속성으로 구현한다.<br/>

-   `IPerson.ts`

```typescript
import { ILocation } from "../location";

export type IPerson = {
    name: string;
    age: number;
    title?: string;
    location?: ILocation;
};

export { ILocation };
```

작성한 `IPerson` 객체를 생성하는 `makeIPerson` 함수를 구현한다.<br/>

-   `makeIPerson.ts`

```typescript
import { IPerson, ILocation } from "./IPerson";

export const makeIPerson = (
    name: string,
    age: number,
    title?: string,
    location?: ILocation
): IPerson => ({ name, age, title, location });

export { IPerson, ILocation };
```

`chance` 패키지를 이용해 `IPerson`의 데이터를 생성하는 `makeRandomIPerson` 함수를 구현한다.<br/>

-   `makeRandomIPerson.ts`

```typescript
import { makeRandomILocation } from "../location";
import { IPerson, makeIPerson } from "./makeIPerson";
import Chance from "chance";

const c = new Chance();

export const makeRandomIPerson = (): IPerson =>
    makeIPerson(c.name(), c.age(), c.profession(), makeRandomILocation());
```

마지막으로 `src/model/person` 폴더에서 아래 내용의 `index.ts`를 작성한다.<br/>

-   `index.ts`

```typescript
import { IPerson, makeIPerson } from "./makeIPerson";
import { makeRandomIPerson } from "./makeRandomIPerson";

export { IPerson, makeIPerson, makeRandomIPerson };
```

`src` 폴더에 아래와 같은 내용으로 작성한 함수를 테스트할 수 있다.<br/>

```typescript
import { IPerson, makeRandomIPerson } from "./model/person";

const person: IPerson = makeRandomIPerson();
console.log(person);
// {
//   name: 'Esther Benson',
//   age: 31,
//   title: 'Executive Assistant',
//   location: {
//     country: 'SK',
//     city: 'Mobipev',
//     address: '1058 Jenfog Grove',
//     coordinates: { latitude: 12.09187, longitude: -174.44386 }
//   }
// }
```

`makeRandomIPerson` 함수를 호출하면 `IPerson` 타입의 데이터가 랜덤하게 생성된다.<br/>

[[🔝위로가기]](#09장-람다-라이브러리)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 09-7 렌즈를 활용한 객체의 속성 다루기

### 렌즈란?

**렌즈**는 하스켈 언어의 `Control.Lens` 내용 중 **Getter**와 **Setter** 기능만 `ramda`로 구현한 것이다.<br/>
`ramda`의 **렌즈** 기능을 활용하면 객체의 속성값을 얻거나 설정하는 등의 작업을 쉽게 할 수 있다.<br/>
**렌즈** 기능은 아래와 같은 과정을 진행하는 방식으로 이용한다.

1. `R.lens` 함수로 객체의 특정 속성에 대한 **렌즈**를 만든다.
2. **렌즈**를 `R.view` 함수에 적용해 속성값을 얻는다.
3. **렌즈**를 `R.set` 함수에 적용해 속성값이 바뀐 새로운 객체를 얻는다.
4. **렌즈**와 속성값을 바꾸는 함수를 `R.over` 함수해 적용해 값이 바뀐 새로운 객체를 얻는다.

**렌즈** 기능은 객체의 특정 속성에 대한 렌즈를 만들고 그 렌즈에 함수를 적용해 사용한다.<br/>

### R.prop과 R.assoc 함수

`R.prop`은 `property`의 앞 네 글자를 따서 만든 함수 이름이다.<br/>
`R.prop`은 객체의 특정 **속성값을 가져오는 함수**로 이런 동작을 하는 함수를 **Getter**라고 한다.<br/>

-   `R.prop` 함수를 사용하는 예시

```typescript
import * as R from "ramda";
import { IPerson, makeRandomIPerson } from "./model/person";

const person: IPerson = makeRandomIPerson();

const name = R.pipe(
    R.prop("name"),
    R.tap((name) => console.log(name)) // Curtis Henry
)(person);
```

`R.prop` 함수를 이용해 `IPerson` 타입 객체의 `name`속성을 가져온 것을 볼 수 있다.<br/>
객체의 특정 속성값을 변경하려면 `R.assoc` 함수를 사용한다.<br/>
이렇게 객체의 특정 속성값을 변경하는 목적으로 사용하는 함수를 **Setter**라고 한다.<br/>

-   `R.assoc` 함수를 사용하는 예시

```typescript
import * as R from "ramda";
import { IPerson, makeRandomIPerson } from "./model/person";

const getName = R.pipe(
    R.prop("name"),
    R.tap((name) => console.log(name))
);

const person: IPerson = makeRandomIPerson();
const originalName = getName(person); // Hester Lawson

const modifiedPerson = R.assoc("name", "Albert Einstein")(person);
const modifiedName = getName(modifiedPerson); // Albert Einstein
```

`IPerson` 객체의 값을 `R.assoc`함수를 이용해 `name` 속성값을 `Albert Einstein`으로 변경하였다.<br/>

### R.lens 함수

**렌즈** 기능을 사용하기 위해서는 일단 **렌즈**를 만들어야 한다.<br/>
**렌즈**는 아래와 같이 `R.lens`, `R.prop`, `R.assoc`의 조합으로 만들 수 있다.<br/>

```typescript
export const makeLens = (propName: string) =>
    R.lens(R.prop(propName), R.assoc(propName));
```

`R.lens` 함수에 첫 번째 인자에는 `R.prop`함수 두 번쨰 인자에는 `R.assoc` 함수를 전달하면 된다.<br/>

### R.view, R.set, R.over 함수

만들어진 **렌즈**는 `R.view`, `R.set`, `R.over` 함수에 **렌즈**를 적용해 사용할 수 있다.<br/>
아래 예시는 **렌즈**를 적용해 `getter`와 `setter`, `setterUsingFunc` 함수를 만든 예시다.<br/>

```typescript
import * as R from "ramda";

export const makeLens = (propName: string) =>
    R.lens(R.prop(propName), R.assoc(propName));

export const getter = (lens) => R.view(lens);
export const setter = (lens) => <T>(newValue: T) => R.set(lens, newValue);
export const setterUsingFunc = (lens) => <T, R>(func: (T) => R) =>
    R.over(lens, func);
```

위와 같이 작성한 함수는 아래의 코드로 테스트할 수 있다.<br/>

```typescript
import * as R from "ramda";
import { makeLens, getter, setter, setterUsingFunc } from "./Lens";
import { IPerson, makeRandomIPerson } from "./model/person";

const nameLens = makeLens("name");
const getName = getter(nameLens);
const setName = setter(nameLens);
const setNameUsingFunc = setterUsingFunc(nameLens);

const person: IPerson = makeRandomIPerson();

const name = getName(person);
const newPerson = setName("Albert Einstein")(person);
const anotherPerson = setNameUsingFunc((name) => `Mr. ${name}`)(person);
const capitalPerson = setNameUsingFunc(R.toUpper)(person);

console.log(name); // Landon Jackson
console.log(getName(newPerson)); // Albert Einstein
console.log(getName(anotherPerson)); // Mr. Landon Jackson
console.log(getName(capitalPerson)); // LANDON JACKSON
```

위와 같이 코드를 작성하면 `name` 속성 이름은 `makeLens('name')`에서만 사용된다.<br/>
따라서 나중에 속성 이름을 변경할 떄 코드의 다른 부분에 영향을 주지 않는 장점이 있다.<br/>

### R.lensPath 함수

`IPerson` 객체의 `longitude` 값은 `person.location.coordinates.longitude`처럼 작성해야 알 수 있다.<br/>
`ramda` 라이브러리에서는 객체의 이러한 **중첩 속성**을 **경로**라고 한다.<br/>
`longitude`처럼 긴 경로의 속성을 **렌즈**로 만들기 위해서는 `R.lensPath` 함수를 사용한다.<br/>

```typescript
const 렌즈 = R.lensPath(["location", "coordinates", "longitude"]);
```

위와 같이 **렌즈**를 만들면 앞에서 구현한 `getter`, `setter`, `setterUsingFunc` 함수를 바로 적용할 수 있다.<br/>

```typescript
import * as R from "ramda";
import { getter, setter, setterUsingFunc } from "./Lens";
import { IPerson, makeRandomIPerson } from "./model/person";

const longitudeLens = R.lensPath(["location", "coordinates", "longitude"]);
const getLongitude = getter(longitudeLens);
const setLongitude = setter(longitudeLens);
const setLongitudeUsingFunc = setterUsingFunc(longitudeLens);

const person: IPerson = makeRandomIPerson();

const longitude = getLongitude(person);
const newPerson = setLongitude(0.1234567)(person);
const anotherPerson = setLongitudeUsingFunc(R.add(0.1234567))(person);

console.log(longitude); // 34.43953
console.log(getLongitude(newPerson)); // 0.1234567
console.log(getLongitude(anotherPerson)); // 34.562986699999996
```

위 코드는 `R.lensPath`를 이용해 `longitude` 속성의 **렌즈**인 `longitudeLens`를 만든다.<br/>
이후의 코드는 `nameLens` 대신에 `longitudeLens`를 사용하며 함수의 이름과 값만 바뀌었다.<br/>
나머지의 함수 사용법은 `makeLens` 함수를 이용해 만든 `nameLens`를 사용한 예시와 동일하다.<br/>

[[🔝위로가기]](#09장-람다-라이브러리)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 09-8 객체 다루기

### R.toPairs와 R.fromPairs 함수

`R.toPairs` 함수는 객체의 속성들을 분해해 배열로 만들어 준다.<br/>
이때 배열의 각 아이템은 [`string, any]` 타입의 **튜플**이다.<br/>

```typescript
import * as R from "ramda";
import { IPerson, makeRandomIPerson } from "./model/person";

const person: IPerson = makeRandomIPerson();
const pairs: [string, any][] = R.toPairs(person);
console.log("pairs :", pairs);
// pairs : [
//     ['name', 'Beatrice Pierce'],
//     ['age', 44],
//     ['title', 'Gerontologist'],
//     [
//         'location',
//         {
//             country: 'KY',
//             city: 'Dafwufur',
//             address: '1915 Pefob Way',
//             coordinates: [Object]
//         }
//     ]
// ]
```

위 코드의 결과를 보면 `IPerson` 객체의 속성이 `[키, 값]` 형태의 배열로 만들어진 것을 볼 수 있다.<br/>
`R.fromPairs` 함수는 `[키:값]` 형태의 아이템을 가진 배열을 다시 객체로 만들어준다.<br/>

```typescript
import * as R from "ramda";
import { IPerson, makeRandomIPerson } from "./model/person";

const pairs: [string, any][] = R.toPairs(makeRandomIPerson());
const person: IPerson = R.fromPairs(pairs) as IPerson;
console.log("person :", person);
// person : {
//     name: 'Katie Andrews',
//         age: 52,
//             title: 'Tax Specialist',
//                 location: {
//         country: 'HT',
//             city: 'Cesobi',
//                 address: '1031 Aredam Point',
//                     coordinates: { latitude: 83.41045, longitude: -78.94807 }
//     }
// }
```

`R.toPairs` 함수로 만들어진 `[string, any][]` 타입의 배열이 `IPerson` 타입 객체로 변환되었다.<br/>

### R.keys와 R.values 함수

`R.keys` 함수는 객체의 속성 이름만 추려서 `string[]` 타입 배열로 반환한다.<br/>
아래 코드는 `IPerson` 객체에 `R.keys` 함수를 적용한 예시다.<br/>

```typescript
import * as R from "ramda";
import { makeRandomIPerson } from "./model/person";

const keys: string[] = R.keys(makeRandomIPerson());
console.log("keys :", keys); // keys : [ 'name', 'age', 'title', 'location' ]
```

`IPerson`이 객체의 속성 이름인 `name`, `age`, `title`, `location`을 갖는 배열이 반환되었다.<br/>
`R.values` 함수는 객체의 속성값만 추려 `any[]` 타입 배열로 반환한다.<br/>

```typescript
import * as R from "ramda";
import { makeRandomIPerson } from "./model/person";

const values: any[] = R.values(makeRandomIPerson());
console.log("values :", values);
// values : [
//     'Shane Lawson',
//     31,
//     'IT Architect',
//     {
//         country: 'AU',
//         city: 'Hegjedzi',
//         address: '690 Etvul Manor',
//         coordinates: { latitude: 80.53795, longitude: -117.13029 }
//     }
// ]
```

`IPerson` 타입 객체의 속성값들이 배열 형태로 반환된 것을 볼 수 있다.<br/>

### R.zipObj 함수

`R.zipObj` 함수는 `key` 배열과 `value` 배열이라는 두 매개변수를 결합해 객체로 만들어준다.<br/>

```typescript
객체 = R.zipObj(key 배열, value 배열)
```

아래 코드는 `R.keys`와 `R.values`로 얻는 `keys`와 `values`를 `R.zipObj` 함수로 결합하는 예시다.<br/>

```typescript
import * as R from "ramda";
import { makeRandomIPerson, IPerson } from "./model/person";

const originalPerson: IPerson = makeRandomIPerson();
const keys: string[] = R.keys(originalPerson);
const values: any[] = R.values(originalPerson);
const zippedPerson: IPerson = R.zipObj(keys, values) as IPerson;

console.log("originalPerson :", originalPerson, "zippedPerson :", zippedPerson);
// originalPerson: {
//     name: 'Vincent Stevens',
//         age: 21,
//             title: 'Land Developer',
//                 location: {
//         country: 'NE',
//             city: 'Domidgek',
//                 address: '1856 Gulsor Grove',
//                     coordinates: { latitude: 13.85609, longitude: -1.41191 }
//     }
// } zippedPerson: {
//     name: 'Vincent Stevens',
//         age: 21,
//             title: 'Land Developer',
//                 location: {
//         country: 'NE',
//             city: 'Domidgek',
//                 address: '1856 Gulsor Grove',
//                     coordinates: { latitude: 13.85609, longitude: -1.41191 }
//     }
// }
```

`R.zipObj` 함수로 결합된 `zippedPerson` 객체가 `originalPerson` 객체와 동일한 것을 볼 수 있다.<br/>

### R.mergeLeft와 R.mergeRight 함수

`R.mergeLeft`와 `R.mergeRight` 함수는 두 객체를 받아 두 객체의 속성을 결합해 객체를 생성한다.<br/>

```typescript
새로운 객체 = R.mergeLeft(객체1)(객체2)
새로운 객체 = R.mergeRight(객체1)(객체2)
```

두 함수가 Left, Right로 나뉜 이유는 객체에 같은 속성이 있고 값은 다를 때 값을 선택하기 위해서다.<br/>
`R.mergeLeft` 함수는 왼쪽 객체의 값인 객체1의 우선순위가 더 높다.<br/>
`R.mergeRight` 함수는 오른쪽 객체의 값인 객체2의 우선순위가 더 높다.<br/>

```typescript
import * as R from "ramda";

const left = { name: "Jack" },
    right = { name: "Jane", age: 32 };
const person = R.mergeLeft(left, right);
console.log(person); // { name: 'Jack', age: 32 }
```

위의 코드에서 `left`와 `right` 객체 모두 `name` 속성을 가지고 있다.<br/>
`R.mergeLeft` 함수를 사용하므로 `left` 객체의 `name` 속성이 우선순위가 더 높다.<br/>
따라서 결합된 객체인 `person`의 `name` 속성값이 `left` 객체의 `Jack`이 된 것을 볼 수 있다.<br/>

```typescript
import * as R from "ramda";

const left = { name: "Jack" },
    right = { name: "Jane", age: 32 };
const person = R.mergeRight(left, right);
console.log(person); // { name: 'Jane', age: 32 }
```

반대로 `R.mergeRight`를 사용할 경우 `right` 객체의 속성이 우선순위가 더 높다.<br/>
결합된 객체인 `person`의 `name` 속성값이 위와 반대로 `Jane`이 된 것을 볼 수 있다.<br/>

### R.mergeDeepLeft와 R.mergeDeepRight 함수

`R.mergeLeft`와 `R.mergeRight` 함수는 객체의 속성에 담긴 객체를 바꾸지 못한다.<br/>
`IPerson`의 속성값들만 바꾸어줄 뿐 `location.coordinates`의 속성값은 변경할 수 없다.<br/>
`R.mergeDeepLeft`와 `R.mergeDeepRight` 함수는 `location`과 같은 경로의 속성값들도 바꿀 수 있다.<br/>

```typescript
import * as R from "ramda";
import { IPerson, makeRandomIPerson } from "./model/person";
import { ILocation, makeRandomILocation } from "./model/location";
import { ICoordinates, makeRandomICoordinates } from "./model/coordinates";

const person: IPerson = makeRandomIPerson();
const location: ILocation = makeRandomILocation();
const coordinates: ICoordinates = makeRandomICoordinates();

const newLocation = R.mergeDeepRight(location, { coordinates });
const newPerson = R.mergeDeepRight(person, { location: newLocation });

console.log("person :", person);
console.log("newPerson :", newPerson);
// person : {
//     name: 'Georgie Doyle',
//         age: 39,
//             title: 'Computer Programmer',
//                 location: {
//         country: 'MD',
//             city: 'Nukaven',
//                 address: '1958 Uscu Plaza',
//                     coordinates: { latitude: -17.70018, longitude: -60.19292 }
//     }
// }
// newPerson : {
//     name: 'Georgie Doyle',
//         age: 39,
//             title: 'Computer Programmer',
//                 location: {
//         country: 'GH',
//             city: 'Majuig',
//                 address: '1398 Vougo Park',
//                     coordinates: { latitude: -31.62073, longitude: -85.10003 }
//     }
// }
```

위의 코드에서 `person`과 `newPerson`의 내용을 비교하면 `location`과 `coordinates` 부분만 바뀌었다.<br/>
위와 같이 `R.mergeDeepRight` 함수는 객체의 속성외에도 객체의 경로의 속성값도 바꿀 수 있다.<br/>

[[🔝위로가기]](#09장-람다-라이브러리)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 09-9 배열 다루기

### R.prepend와 R.append 함수

`R.prepend`와 `R.append` 함수는 기존 배열의 앞뒤에 새 아이템을 삽입한 새 배열을 만든다.<br/>
아래 코드는 `R.prepend` 함수를 사용해 배열의 맨 앞에 아이템을 삽입한다.<br/>

```typescript
import * as R from "ramda";

const array: number[] = [3, 4];
const newArray = R.prepend(1)(array);
console.log(array, newArray); // [ 3, 4 ] [ 1, 3, 4 ]
```

반면에 아래 코드는 `R.append` 함수를 사용해 배열의 맨 뒤에 아이템을 삽입한다.<br/>

```typescript
import * as R from "ramda";

const array: number[] = [3, 4];
const newArray = R.append(1)(array);
console.log(array, newArray); // [ 3, 4 ] [ 3, 4, 1 ]
```

배열에 `Array.push`같은 함수를 이용해 아이템을 직접 삽입하면 기존 배열의 내용이 훼손된다.<br/>
따라서 **순수 함수** 관점에서 기존 배열을 훼손하지 않기 위해 이러한 함수들이 만들어졌다.<br/>

### R.flatten 함수

배열의 구조가 다음처럼 복잡하게 되어있으면 `ramda` 라이브러리의 기능을 적용하는 것은 어렵다.<br/>

```typescript
[
    [
        [1, 1],
        [1, 2],
    ],
    [
        [2, 1],
        [2, 2],
    ],
];
```

`R.flatten` 함수는 위와 같이 복잡한 배열을 1차원의 평평한 형태로 바꾸어준다.<br/>

```typescript
import * as R from "ramda";

const array = R.range(1, 2 + 1).map((x: number) => {
    return R.range(1, 2 + 1).map((y: number) => {
        return [x, y];
    });
});

console.log(array); // [ [ [ 1, 1 ], [ 1, 2 ] ], [ [ 2, 1 ], [ 2, 2 ] ] ]

const flattedArray = R.flatten(array);
console.log(flattedArray); // [  1, 1, 1, 2, 2, 1, 2, 2]
```

위의 코드에서 `array` 배열은 복잡한 3차원 형태로 구성되어있다.<Br/>
`R.flatten` 함수를 사용하면 복잡한 형태의 배열을 1차원 형태로 바꿀 수 있다.<br/>

### R.unnest 함수

`R.unnest` 함수는 `R.flatten`보다 조금 정교하게 배열을 가공해준다.<br/>

```typescript
import * as R from "ramda";

const array = R.range(1, 2 + 1).map((x: number) => {
    return R.range(1, 2 + 1).map((y: number) => {
        return [x, y];
    });
});

console.log(array); // [ [ [ 1, 1 ], [ 1, 2 ] ], [ [ 2, 1 ], [ 2, 2 ] ] ]

const unnestedArray = R.unnest(array);
console.log(unnestedArray); // [ [ 1, 1 ], [ 1, 2 ], [ 2, 1 ], [ 2, 2 ] ]

const twoUnnestedArray = R.unnest(unnestedArray);
console.log(twoUnnestedArray); // [ 1, 1, 1, 2, 2, 1, 2, 2 ]
```

`R.unnest` 함수를 한 번 사용한 `unnestedArray`는 3차원 형태의 배열에서 2차원 형태의 배열이 되었다.<br/>
두 번 사용한 `twoUnnestedArray`는 `R.faltten`을 사용한 결과와 같은 1차원 형태의 배열이 되었다.<br/>

### R.sort 함수

배열의 타입이 `number[]`라면 `R.sort` 함수를 사용해 배열을 내림차순이나 오름차순으로 정렬할 수 있다.<br/>
`R.sort` 함수는 첫 번째 매개변수에 콜백 함수를 입력받는 **2차 고차 함수**다.<br/>

```typescript
정렬된 배열 = R.sort(콜백 함수)(배열)
```

`R.sort` 함수의 콜백 함수는 아래와 같이 구현해야 한다.<br/>

```typescript
(a: number, b: number): number => a - b;
```

콜백 함수의 결과가 **음수**이면 **오름차순**, **0이거나 양수**면 **내림 차순**으로 정렬이 된다.<br/>

```typescript
import * as R from "ramda";

type voidToNumberFunc = () => number;
const makeRandomNumber = (max: number): voidToNumberFunc => (): number =>
    Math.floor(Math.random() * max);

const array = R.range(1, 5 + 1).map(makeRandomNumber(100));
const sortedArray = R.sort((a: number, b: number): number => a - b)(array);
console.log(array, sortedArray); // [ 20, 55, 9, 13, 51 ] [ 9, 13, 20, 51, 55 ]
```

위의 코드는 랜덤하게 생성한 수 배열을 오름차순으로 정렬한 예시다.<br/>

### R.sortBy 함수

배열에 담긴 아이템이 객체라면 특정 속성값에 따라 정렬해야 하므로 이때 `R.sortBy` 함수를 사용한다.<br/>

```typescript
정렬된 배열 = R.sortBy(객체의 속성을 얻는 함수)(배열)
```

아래 코드는 `IPerson` 객체 배열을 대상으로 `name` 속성과 `age` 속성에 따른 정렬을 보여준다.<br/>

```typescript
import * as R from "ramda";
import { IPerson, makeRandomIPerson } from "./model/person";

const dispalyPersons = (prefix: string) =>
    R.pipe(
        R.map((person: IPerson) => ({ name: person.name, age: person.age })),
        R.tap((o) => console.log(prefix, o))
    ) as any;

const persons: IPerson[] = R.range(1, 4 + 1).map(makeRandomIPerson);
const nameSortedPersons = R.sortBy(R.prop("name"))(persons);
const ageSortedPersons = R.sortBy(R.prop("age"))(persons);

dispalyPersons("Sorted by name :")(nameSortedPersons);
// Sorted by name : [
//     { name: 'Catherine Colon', age: 60 },
//     { name: 'Cody McGuire', age: 41 },
//     { name: 'Millie Jackson', age: 58 },
//     { name: 'Sara Gordon', age: 43 }
// ]
dispalyPersons("Sorted by age :")(ageSortedPersons);
// Sorted by age : [
//     { name: 'Cody McGuire', age: 41 },
//     { name: 'Sara Gordon', age: 43 },
//     { name: 'Millie Jackson', age: 58 },
//     { name: 'Catherine Colon', age: 60 }
// ]
```

`nameSortedPersons`, `ageSortedPersons` 배열 모두 `R.prop` 함수로 지정한 속성값을 기준으로 오름차순 정렬되었다.<br/>

### R.sortWith 함수

`R.sortBy` 함수는 항상 오름차순으로만 배열을 정렬한다.<br/>
`R.sortWith` 함수는 `R.ascend`, `R.descend` 함수와 함께 사용해 오름차순, 내림차순 정렬이 가능하다.<Br/>

```typescript
import * as R from "ramda";
import { IPerson, makeRandomIPerson } from "./model/person";

const dispalyPersons = (prefix: string) =>
    R.pipe(
        R.map((person: IPerson) => ({ name: person.name, age: person.age })),
        R.tap((o) => console.log(prefix, o))
    ) as any;

const persons: IPerson[] = R.range(1, 4 + 1).map(makeRandomIPerson);
const nameSortedPersons = R.sortWith([R.descend(R.prop("name"))])(persons);

dispalyPersons("Sorted by name :")(nameSortedPersons);
// Sorted by name: [
//     { name: 'Gilbert Terry', age: 49 },
//     { name: 'Gary Wagner', age: 23 },
//     { name: 'Eugenia French', age: 41 },
//     { name: 'Ada Perez', age: 60 }
// ]
```

위 코드는 `R.descend` 함수를 이용해 `IPerson` 타입 객체의 `name` 속성을 기준으로 내림차순 정렬을 한다.<br/>

[[🔝위로가기]](#09장-람다-라이브러리)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 09-10 조합 논리 이해하기

[[🔝위로가기]](#09장-람다-라이브러리)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
