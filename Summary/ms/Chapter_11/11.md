# 11장 모나드

<details><summary>Table of Contents</summary>

-   11-1 모나드 이해하기 [:link:](#11-1-모나드-이해하기)
    -   타입 클래스란? [:link:](#타입-클래스란)
    -   고차 타입이란? [:link:](#고차-타입이란)
    -   카테고리 이론이란? [:link:](#카테고리-이론이란)
    -   판타지랜드 규격 [:link:](#판타지랜드-규격)
    -   모나드 룰 [:link:](#모나드-룰)
-   11-2 Identity 모나드 이해와 구현 [:link:](#11-2-identity-모나드-이해와-구현)
    -   프로젝트 구성 [:link:](#프로젝트-구성)
    -   값 컨테이너 구현용 IValuable\<T> 인터페이스 구현 [:link:](#값-컨테이너-구현용-ivaluablet-인터페이스-구현)
    -   클래스 이름이 왜 Identity 인가? [:link:](#클래스-이름이-왜-identity-인가)
    -   값 컨테이너로서의 Identity\<T> 구현하기 [:link:](#값-컨테이너로서의-identityt-구현하기)
    -   ISetoid\<T> 인터페이스와 구현 [:link:](#isetoidt-인터페이스와-구현)
    -   IFunctor\<T> 인터페이스와 구현 [:link:](#ifunctort-인터페이스와-구현)
    -   엔도펑터란? [:link:](#엔도펑터란)
    -   IApply\<T> 인터페이스와 구현 [:link:](#iapplyt-인터페이스와-구현)
    -   IApplicative\<T> 인터페이스와 구현 [:link:](#iapplicativet-인터페이스와-구현)
    -   IChian\<T> 인터페이스와 구현 [:link:](#ichiant-인터페이스와-구현)
    -   IMonad\<T> 인터페이스와 구현 [:link:](#imonadt-인터페이스와-구현)
-   11-3 Maybe 모나드 이해와 구현 [:link:](#11-3-maybe-모나드-이해와-구현)
-   11-4 Validation 모나드 이해와 구현 [:link:](#11-4-validation-모나드-이해와-구현)
-   11-5 IO 모나드 이해와 구현 [:link:](#11-5-io-모나드-이해와-구현)

</details>

## 11-1 모나드 이해하기

### 타입 클래스란?

**타입 클래스**의 필요성을 이해하는 것은 **모나드**를 이해하기 위해 중요하다.<br/>
아래의 2차 고차 함수 `callMap`은 고차 매개변수 `b`가 `map` 메서드를 가졌다는 가정으로 구현되었다.<br/>

```typescript
const callMap = (fn) => (b) => b.map(fn);
```

따라서 아래와 같은 코드를 사용하면 정상적으로 작동한다.<br/>

```typescript
callMap((a) => a + 1)([1]);
```

하지만 아래와 같이 작성시 프로그램이 비정상적으로 종료된다.<br/>

```typescript
callMap((a) => a + 1)(1);
```

이를 방지하려면 아래처럼 매개변수 `b`는 반드시 `map` 메서드가 있는 타입으로 제한해야 한다.<br/>

```typescript
const callMap = <T, U>(fn: (T) => U) => <T extends { map(fn) }>(b: T) =>
    b.map(fn);
```

아래와 같이 `map` 메서드가 없는 `1`은 고차 매개변수로 사용할 수 없다.<br/>

<img src="./images/1.png" width="500" height="auto">

따라서 코드를 작성하는 시점에 프로그램이 비정상적으로 정료되는 것을 막을 수 있다.<br/>
보통 객체지향 언어라면 `map` 메서드를 갖는 `Number` 클래스를 구현하는 식으로 설계할 것이다.<br/>
하지만 **모나드** 방식 설계는 반드시 `map`과 `of`라는 메서드가 있는 `Monad<T>` 클래스를 만든다.<br/>

```typescript
class Monad<T> {
    constructor(public value: T) {}
    static of<U>(value: U): Monad<U> {
        return new Monad<U>(value);
    }
    map<U>(fn: (x: T) => U): Monad<U> {
        return new Monad<U>(fn(this.value));
    }
}
```

이처럼 `Monad<T>`와 같은 클래스를 **타입 클래스**라고 한다.<br/>
**타입 클래스**는 다음처럼 함수를 만들 때 특별한 타입으로 제약하지 않아도 된다.<br/>

```typescript
const callMonad = (fn) => (b) => Monad.of(b).map(fn).value;
```

**타입 클래스** 덕분에 **타입에 따른 안정성을 보장**하고 코드의 **재사용성이 뛰어난 범용 함수**를 쉽게 만들 수 있다.<br/>

```typescript
callMonad((a: number) => a + 1)(1); // 2
callMonad((a: number[]) => a.map((value) => value + 1))([1, 2, 3, 4]); // [ 2, 3, 4, 5 ]
```

`callMonad`와 같은 함수는 한 번만 만들면 위처럼 **매개변수의 타입에 무관**한 간결한 코드를 작성할 수 있다.<br/>

### 고차 타입이란?

`Monad<T>`는 타입 `T`를 `Monad<T>`로 변환했다 다시 타입 `T`로 변환해준다.<br/>
`Monad<T>`와 같이 타입 `T`를 한 단계 더 높은 타입으로 변환하는 용도의 타입을 **고차 타입**이라 한다.<br/>
**고차 타입**은 **카테고리 이론**이라는 수학에서 아이디어를 얻었다.<br/>
Typescript에서는 `Monad<T>`와 같이 **2차 고차 타입**을 만들 수 있게 하는 구문을 제공한다.<br/>
하지만 스칼라 언어처럼 `Functor[F[_]]` 같은 3차 이상의 고차 타입은 만들 수 없다.<br/>

### 카테고리 이론이란?

**카테고리 이론**은 1940년에 시작된 수학의 한 분야로 함수형 프로그래밍 언어의 중요한 이론적인 배경이 되었다.<br/>
**카테고리 이론**은 흔히 아래의 그림으로 표현된다.<br/>

<img src="./images/2.png" width="500" height="auto">

수학에서 **집합**은 프로그래밍에서의 **타입**이다.<br/>
수학에서 **카테고리**는 **집합의 집합**으로 이해할 수 있다.<br/>
따라서 프로그래밍에서의 **카테고리**는 **타입의 타입**으로 **고차 타입**으로 이해할 수 있다.<br/>
또한 **모나드**는 별도의 특징이 있는 **고차 타입**이다.<br/>

### 판타지랜드 규격

**모나드**는 하스켈 언어의 `Prelude`라는 표준 라이브러리에서 사용되는 용어이기도 하다.<br/>
**모나드**는 **모나드 룰**이라고 하는 코드 설계 원칙에 맞춰 구현된 클래스를 의미한다.<br/>
아래 그림은 Github에 있는 [판타지랜드 규격](https://github.com/fantasyland/fantasy-land)에 있는 그림 중 부분이다.<br/>

<img src="./images/3.png" width="550" height="auto">

판타지랜드 규격은 하스켈 표준 라이브러리 구조를 Javascript 방식으로 재구성한 것이다.<br/>
그림에서 보면 **모나드**는 아래 네 가지 요소를 구현한 것임을 알 수 있다.<br/>

-   **펑터**(**Functor**) : `map`이라는 인스턴스 메서드를 가지는 클래스
-   **어플라이**(**Apply**) : **펑터**이면서 `ap`라는 인스턴스 메서드를 가지는 클래스
-   **애플리커티브**(**Applicative**) : **어플라이**이면서 `of`라는 클래스 메서드를 가지는 클래스
-   **체인**(**Chain**) : **애플리커티브**이면서 `chain`이라는 메서드를 가지는 클래스

어떤 클래스가 위의 네 가지 조건을 모두 만족한다면 그 클래스는 **모나드**다.<br/>

### 모나드 룰

클래스 이름이 `M`이고 인스턴스를 `m`이라고 할때 **모나드**는 **애플리커티브**와 **체인**의 기능을 갖는다.<br/>
또한 해당 **모나드** 클래스는 아래와 같은 두 가지 법칙을 만족한다.<br/>

|             구분             |            의미            |
| :--------------------------: | :------------------------: |
|  왼쪽 법칙 (Left Identity)   | `M.of(a).chain(f) == f(a)` |
| 오른쪽 법칙 (Right Identity) |    `m.chain(M.of) == m`    |

하스켈의 `Prelude` 표준 라이브러리는 `Maybe`와 같은 미리 구현된 **모나드**를 제공한다.<br/>
Typescript는 **모나드** 라이브러리를 제공하지 않으므로 **판타지랜드 규격**에 맞춰 작성해야 한다.<br/>

[[🔝위로가기]](#11장-모나드)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-2 Identity 모나드 이해와 구현

### 프로젝트 구성

아래와 같이 Typescript를 사용하는 node.js 프로젝트를 구성한다.<br/>

```shell
> npm init --y
> npm i -D typescript ts-node @types/node
> mkdir -p src/test
> mkdir src/interfaces
> mkdir src/classes
```

`tsconfig.json` 파일은 아래와 같이 설정한다.<br/>

```typescript
{
    "compilerOptions": {
        "module": "CommonJS",
        "esModuleInterop": true,
        "target": "es5",
        "moduleResolution": "node",
        "outDir": "dist",
        "baseUrl": ".",
        "sourceMap": true,
        "downlevelIteration": true,
        "noImplicitAny": false,
        "paths": {
            "*": ["node_modules/*"]
        }
    },
    "include": ["src/**/*"]
}
```

기존에 사용했던 `tsconfig.json` 파일 설정들과 동일하게 설정하였다.<br/>

### 값 컨테이너 구현용 IValuable\<T> 인터페이스 구현

어떤 타입 `T`가 있을 때 배열 `T[]`는 같은 타입의 아이템을 여러 개 가진 **컨테이너**다.<br/>
보통 **컨테이너**라는 용어는 이처럼 흔히 **배열**을 의미한다.<br/>
하지만 `Monad<T>`처럼 **배열이 아닌 한 개의 값을 가지는 컨테이너 클래스**를 생각할 수 있다.<br/>
이 **컨테이너 클래스**는 모든 타입 `T`의 값을 가질 수 있는 **제네릭 컨테이너 클래스**다.<br/>
이처럼 타입 `T`를 가지는 값의 컨테이너를 **값 컨테이너**라고 한다.<br/>
**값 컨테이너**를 구현하기 위해 아래의 `IValuable<T>` 인터페이스를 작성한다.<br/>

-   `interfaces/IValuable.ts`

```typescript
export interface IValuable<T> {
    value(): T;
}
```

또한 앞으로 `Identity<T>`의 코드를 편하게 사용하고자 아래의 내용의 `index.ts`를 작성한다.<br/>

-   `interfaces/index.ts`

```typescript
import { IValuable } from "./IValuable";
import { ISetoid } from "./ISetoid";
import { IFunctor } from "./IFunctor";
import { IApplicative } from "./IApplicative";
import { IApply } from "./IApply";
import { IChain } from "./IChain";
import { IMonad } from "./IMonad";

export { IValuable, ISetoid, IFunctor, IApplicative, IApply, IChain, IMonad };
```

### 클래스 이름이 왜 Identity 인가?

**함수형 프로그래밍**에서 `identity`는 항상 아래처럼 구현하는 특별한 의미의 함수다.<br/>

```typescript
const identity = <T>(value: T): T => value;
```

앞에서 본 `ramda` 라이브러리의 `R.identity` 함수가 `identity`를 구현하고 있다.<br/>
`Identity`는 `map`, `ap`, `of`, `chain`과 같은 기본 메서드만 구현한 **모나드**다.<br/>
**카테고리 이론**에서 기존 타입에서 다른 타입으로 갔다 올 때 **값이 변경되지 않는 카테고리**를 `Identity`라고 한다.<br/>

```typescript
Identity.of(1).chain(Identity.of); // Identity.of(1)
```

위 코드의 `Identity<number>` 타입은 `chain` 메서드를 통해 다시 자신의 타입으로 돌아올 수 있다.<br/>

### 값 컨테이너로서의 Identity\<T> 구현하기

아래의 `Identity` 클래스는 값 속성인 `_value`를 `private`하게 가지고 있다.<br/>
따라서 `_value`를 얻기 위해 `public`한 `value` 메서드를 사용해야 한다.<br/>

-   `classes/Identity.ts`

```typescript
import { IValuable } from "../interfaces";

export class Identity<T> implements IValuable<T> {
    constructor(private _value: T) {}
    value() {
        return this._value;
    }
}
```

`Identity<T>` 클래스는 `IValuable<T>` 인터페이스를 구현하고 있는 **값 컨테이너 클래스다**.<br/>

### ISetoid\<T> 인터페이스와 구현

**판타지랜드 규격**에서 `setoid`는 `equals`라는 이름의 메서드를 제공하는 인터페이스를 의미한다.<br/>

-   `interfaces/ISetoid.ts`

```typescript
import { IValuable } from "./IValuable";

export interface ISetoid<T> extends IValuable<T> {
    equals<U>(value: U): boolean;
}
```

Typescript로 `setoid` 인터페이스는 위와 같이 구현할 수 있다.<br/>
`ISetoid<T>`에는 값이 없기 때문에 값을 비교하기 위해 `IValuable<T>` 인터페이스를 상속한다.<br/>
`Identity<T>`에 `ISetoid<T>` 인터페이스를 아래와 같이 구현할 수 있다.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid } from "../interfaces";

export class Identity<T> implements ISetoid<T> {
    constructor(private _value: T) {}
    value() {
        return this._value;
    }
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }
}
```

`ISetoid<T>` 인터페이스를 상속한 후 `equals` 함수를 위와 같이 구현하였다.<br/>
아래의 테스트 코드를 사용해 구현된 `ISetoid<T>` 클래스를 테스트할 수 있다.<br/>

-   `test/ISetoid-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const one = new Identity(1),
    anotherOne = new Identity(1);
const two = new Identity(2);

console.log(one.equals(anotherOne)); // true
console.log(one.equals(two)); // false
console.log(one.equals(1)); // false
console.log(one.equals(null)); // false
console.log(one.equals([1])); // false
```

변수 `one`은 똑같은 `Identity<number>` 타입 변수인 `anotherOne`에만 `true`를 반환한다.<br/>
`equals` 함수에서 매개변수 `that`이 `Identity`의 인스턴스임을 판별하기 때문이다.<br/>
매개변수 `that`이 `Identity` 인스턴스가 아니면 무조건 `false`를 반환하게 된다.<br/>
만약 `Identity`의 인스턴스라면 `value` 함수로 값을 가져와 `==` 연산자로 비교하게 된다.<br/>

### IFunctor\<T> 인터페이스와 구현

**판타지랜드 규격**에서 **펑터**는 `map`이라는 메서드를 제공하는 인터페이스다.<br/>

-   `interfaces/IFunctor.ts`

```typescript
export interface IFunctor<T> {
    map<U>(fn: (x: T) => U);
}
```

**카테고리 이론**에서 **펑터**는 **엔도 펑터**라는 특별한 성질을 만족해야 한다.<br/>
Typescript 3.7.4 버전에서는 **엔도펑터**를 구현할 수 있게 하는 구문을 제공하지 않는다.<br/>
따라서 `IFunctor`의 `map` 메서드의 반환 타입을 생략한 이유는 **엔도 펑터**를 구현하기 위해서다.<br/>

### 엔도펑터란?

**엔도**는 단어 앞에 붙는 일종의 접두사다.<br/>
**엔도펑터**는 특정 카테고리에서 출발해 **다시 출발 카테고리로 도착**하는 **펑터**를 의미한다.<br/>
아래의 `Identity<T>`의 `map` 메서드의 구현 내용은 **엔도펑터**로 동작하게 하는 코드다.<br/>

-   `classes/Identtiy.ts`

```typescript
import { ISetoid, IFunctor } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IFunctor<T> {
    constructor(private _value: T) {}

    // IValualbe
    value() {
        return this._value;
    }

    // ISetoid
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }

    // IFunctor
    map<U>(fn: (x: T) => U) {
        return new Identity<U>(fn(this.value()));
    }
}
```

값 타입 `T`가 `U`로 바뀔 수는 있지만 **카테고리**는 여전히 `Identity`에 머물게 한다.<br/>

### IApply\<T> 인터페이스와 구현

**판타지랜드 규격**에서 **어플라이**는 **펑터**이면서 `ap` 메서드를 제공하는 인터페이스다.<br/>

-   `interfaces/IApply.ts`

```typescript
import { IFunctor } from "./IFunctor";

export interface IApply<T> extends IFunctor<T> {
    ap<U>(b: U);
}
```

`IApply<T>`를 구현하는 **컨테이너**는 **값 컨테이너**이며 **고차 함수의 컨테이너**로도 동작한다.<br/>
아래와 같은 테스트 코드로 `IApply`의 동작을 이해할 수 있다.<br/>

-   `test/IApply-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const add = (x) => (y) => x + y;
const id = new Identity(add);

console.log(id.ap(1).ap(2).value()); // 3
```

`Identity`는 `add`라는 **2차 고차 함수**를 값으로 가지고 있다.<br/>
`add`는 **2차 고차 함수**이므로 `ap` 메서드를 두 번 호출해 함수를 동작시킨다.<br/>

```typescript
import { ISetoid, IApply } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApply<T> {
    // ... 생략 ...
    ap<U>(b: U) {
        const f = this.value();

        if (f instanceof Function) {
            return Identity.of<U>((f as Function)(b));
        }
    }
}
```

`IApply<T>` 인터페이스를 구현하는 `Identity` 클래스의 `ap` 메서드는 위와 같다.<br/>

### IApplicative\<T> 인터페이스와 구현

**판타지랜드 규격**에서 **애플리커티브**는 `Apply`면서 `of`라는 클래스 메서드를 제공하는 인터페이스다.<br/>

-   `interfaces/IApplicative.ts`

```typescript
import { IApply } from "./IApply";

export interface IApplicative<T> extends IApply<T> {
    // static of(value: T);
}
```

Typescript 3.7.4버전에서는 `interface`에 정적 메서드를 구현하지 못한다.<br/>
따라서 위와 같이 주석 처리를 한 후 `Identity` 클래스에 `of` 메서드를 구현해야 한다.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IApplicative } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApplicative<T> {
    // ... 생략 ...
    static of<T>(value: T): Identity<T> {
        return new Identity<T>(value);
    }
}
```

또한 3.7.4 버전의 Typescript는 정적 메서드의 반환 타입에 `this`를 사용할 수 없다.<br/>
따라서 `IApply`의 `of` 메서드의 반환 타입을 생략해 구현하였다.<br/>

### IChian\<T> 인터페이스와 구현

**판타지랜드 규격**의 **체인**은 `Apply`면서 `chain`이라는 메서드를 구현하는 인터페이스다.<br/>

-   `interfaces/chain.ts`

```typescript
import { IApply } from "./IApply";

export interface IChain<T> extends IApply<T> {
    chain<U>(fn: (T) => U);
}
```

**모나드** 특성에 따라 `chain`은 `U` 타입을 반환하지 않을 수 있어 반환 타입을 지정하지 않았다.<br/>
**체인**의 `chain` 메서드는 **펑터**의 `map`과 달리 **엔도펑터**로 구현해야할 의미가 없다.<br/>
따라서 아래 코드의 `chain`은 `map`과 함수 시그니처는 같지만 구현 내용은 조금 다르다.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IApplicative, IChain } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IApplicative<T>, IChain<T> {
    // ... 생략...
    chain<U>(fn: (T) => U): U {
        return fn(this.value());
    }
}
```

**엔도 펑터**인 `map`은 하상 같은 카테고리에 머무른다.<br/>
반면에 `chain`은 자신이 머무르고 싶은 카테고리를 스스로 정해야 한다.<br/>

-   `test/IMap-IChain-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

console.log(
    Identity.of(1)
        .map((value) => `the count is ${value}`)
        .value()
); // the count is 1
console.log(
    Identity.of(1).chain((value) =>
        Identity.of(`the count is ${value}`).value()
    )
); // the count is 1
```

위의 `map`과 `chain`을 사용하는 코드는 같은 결과를 보이지만 사용법에 차이가 있다.<br/>

### IMonad\<T> 인터페이스와 구현

**판타지랜드 규격**에서 **모나드**는 아래처럼 **체인**과 **애플리커티브**를 구현한 것이다.<br/>

-   `interfaces/IMonad.ts`

```typescript
import { IChain } from "./IChain";
import { IApplicative } from "./IApplicative";

export interface IMonad<T> extends IChain<T>, IApplicative<T> {}
```

이제 아래와 같은 `Identity<T>` 모나드가 완성 되었다.<br/>

-   `classes/Identity.ts`

```typescript
import { ISetoid, IMonad } from "../interfaces";

export class Identity<T> implements ISetoid<T>, IMonad<T> {
    constructor(private _value: T) {}

    // IValualbe
    value() {
        return this._value;
    }

    // ISetoid
    equals<U>(that: U): boolean {
        if (that instanceof Identity) {
            return this.value() == that.value();
        }
        return false;
    }

    // IFunctor
    map<U>(fn: (x: T) => U) {
        return new Identity<U>(fn(this.value()));
    }

    // IApply
    ap<U>(b: U) {
        const f = this.value();

        if (f instanceof Function) {
            return Identity.of<U>((f as Function)(b));
        }
    }

    // IApplicative
    static of<T>(value: T): Identity<T> {
        return new Identity<T>(value);
    }

    // IChain
    chain<U>(fn: (T) => U): U {
        return fn(this.value());
    }
}
```

아래 코드는 완성된 `Identity<T>` 모나드가 **왼쪽 법칙**을 만족하는지 테스트하는 코드다.<br/>

-   `test/IMonad-Left-Law-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const a = 1;
const f = (a) => a * 2;

console.log(Identity.of(a).chain(f) == f(a)); // true
```

위의 코드를 실행하면 `true`가 출력됨에 따라 `Identity<T>`가 **모나드 왼쪽 법칙**을 만족한다.<br/>
아래 코드는 `Identity<T>`가 **오른쪽 법칙**을 만족하는지 테스트하는 내용이다.<br/>

-   `test/IMonad-Right-Law-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

const m = Identity.of(1);

console.log(m.chain(Identity.of).equals(m)); // true
```

위의 코드의 결과 역시 `true`가 출력되므로 `Identity<T>`가 **오른쪽 법칙**을 만족한다.<br/>
따라서 `Identity<T>`는 **오른쪽 법칙**과 **왼쪽 법칙** 모두 만족하므로 정상적인 **모나드**다.<br/>
아래 코드는 `Identity` 타입 객체의 메서드들을 메서드 체인 형태로 호출한다.<br/>

-   `test/IMonad-Method-Chain-Test.ts`

```typescript
import { Identity } from "../classes/Identity";

type IPerson = { name: string; age: number };
const jack = Identity.of(["Jack", 32]);

console.log(
    jack
        .map(([name, age]) => ({ name, age }))
        .chain((p: IPerson) => Identity.of(p))
        .map(({ name, age }) => [name, age])
        .value()[0] == jack.value()[0]
); // true
```

**모나드**는 위와 같이 **선언형 프로그래밍**을 염두에 두고 설계되었다.<br/>

[[🔝위로가기]](#11장-모나드)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-3 Maybe 모나드 이해와 구현

[[🔝위로가기]](#11장-모나드)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-4 Validation 모나드 이해와 구현

[[🔝위로가기]](#11장-모나드)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-5 IO 모나드 이해와 구현

[[🔝위로가기]](#11장-모나드)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
