# 11장 모나드

<details><summary>Table of Contents</summary>

-   11-1 모나드 이해하기 [:link:](#11-1-모나드-이해하기)
    -   타입 클래스란? [:link:](#타입-클래스란)
    -   고차 타입이란? [:link:](#고차-타입이란)
    -   카테고리 이론이란? [:link:](#카테고리-이론이란)
    -   판타지랜드 규격 [:link:](#판타지랜드-규격)
    -   모나드 룰 [:link:](#모나드-룰)
-   11-2 Identity 모니드 이해와 구현 [:link:](#11-2-identity-모니드-이해와-구현)
-   11-3 Maybe 모나드 이해와 구현 [:link:](#11-3-maybe-모나드-이해와-구현)
-   11-4 Validation 모나드 이해와 구현 [:link:](#11-4-validation-모나드-이해와-구현)
-   11-5 IO 모나드 이해와 구현 [:link:](#11-5-io-모나드-이해와-구현)

</details>

## 11-1 모나드 이해하기

### 타입 클래스란?

**타입 클래스**의 필요성을 이해하는 것은 **모나드**를 이해하기 위해 중요하다.<br/>
아래의 2차 고차 함수 `callMap`은 고차 매개변수 `b`가 `map` 메서드를 가졌다는 가정으로 구현되었다.<br/>

```typescript
const callMap = (fn) => (b) => b.map(fn);
```

따라서 아래와 같은 코드를 사용하면 정상적으로 작동한다.<br/>

```typescript
callMap((a) => a + 1)([1]);
```

하지만 아래와 같이 작성시 프로그램이 비정상적으로 종료된다.<br/>

```typescript
callMap((a) => a + 1)(1);
```

이를 방지하려면 아래처럼 매개변수 `b`는 반드시 `map` 메서드가 있는 타입으로 제한해야 한다.<br/>

```typescript
const callMap = <T, U>(fn: (T) => U) => <T extends { map(fn) }>(b: T) =>
    b.map(fn);
```

아래와 같이 `map` 메서드가 없는 `1`은 고차 매개변수로 사용할 수 없다.<br/>

<img src="./images/1.png" width="500" height="auto">

따라서 코드를 작성하는 시점에 프로그램이 비정상적으로 정료되는 것을 막을 수 있다.<br/>
보통 객체지향 언어라면 `map` 메서드를 갖는 `Number` 클래스를 구현하는 식으로 설계할 것이다.<br/>
하지만 **모나드** 방식 설계는 반드시 `map`과 `of`라는 메서드가 있는 `Monad<T>` 클래스를 만든다.<br/>

```typescript
class Monad<T> {
    constructor(public value: T) {}
    static of<U>(value: U): Monad<U> {
        return new Monad<U>(value);
    }
    map<U>(fn: (x: T) => U): Monad<U> {
        return new Monad<U>(fn(this.value));
    }
}
```

이처럼 `Monad<T>`와 같은 클래스를 **타입 클래스**라고 한다.<br/>
**타입 클래스**는 다음처럼 함수를 만들 때 특별한 타입으로 제약하지 않아도 된다.<br/>

```typescript
const callMonad = (fn) => (b) => Monad.of(b).map(fn).value;
```

**타입 클래스** 덕분에 **타입에 따른 안정성을 보장**하고 코드의 **재사용성이 뛰어난 범용 함수**를 쉽게 만들 수 있다.<br/>

```typescript
callMonad((a: number) => a + 1)(1); // 2
callMonad((a: number[]) => a.map((value) => value + 1))([1, 2, 3, 4]); // [ 2, 3, 4, 5 ]
```

`callMonad`와 같은 함수는 한 번만 만들면 위처럼 **매개변수의 타입에 무관**한 간결한 코드를 작성할 수 있다.<br/>

### 고차 타입이란?

`Monad<T>`는 타입 `T`를 `Monad<T>`로 변환했다 다시 타입 `T`로 변환해준다.<br/>
`Monad<T>`와 같이 타입 `T`를 한 단계 더 높은 타입으로 변환하는 용도의 타입을 **고차 타입**이라 한다.<br/>
**고차 타입**은 **카테고리 이론**이라는 수학에서 아이디어를 얻었다.<br/>
Typescript에서는 `Monad<T>`와 같이 **2차 고차 타입**을 만들 수 있게 하는 구문을 제공한다.<br/>
하지만 스칼라 언어처럼 `Functor[F[_]]` 같은 3차 이상의 고차 타입은 만들 수 없다.<br/>

### 카테고리 이론이란?

### 판타지랜드 규격

### 모나드 룰

[[🔝위로가기]](#11장-모나드)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-2 Identity 모니드 이해와 구현

[[🔝위로가기]](#11장-모나드)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-3 Maybe 모나드 이해와 구현

[[🔝위로가기]](#11장-모나드)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-4 Validation 모나드 이해와 구현

[[🔝위로가기]](#11장-모나드)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 11-5 IO 모나드 이해와 구현

[[🔝위로가기]](#11장-모나드)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
