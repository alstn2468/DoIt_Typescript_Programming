# 10장 제네릭 프로그래밍

<details><summary>Table of Contents</summary>

-   10-1 제네릭 타입 이해하기 [:link:](#10-1-제네릭-타입-이해하기)
    -   제네릭 타입 [:link:](#제네릭-타입)
    -   제네릭 사용하기 [:link:](#제네릭-사용하기)
-   10-2 제네릭 타입 제약 [:link:](#10-2-제네릭-타입-제약)
-   10-3 대수 데이터 타입 [:link:](#10-3-대수-데이터-타입)
-   10-4 타입 가드 [:link:](#10-4-타입-가드)
-   10-5 F-바운드 다형성 [:link:](#10-5-f-바운드-다형성)
-   10-6 nullable 타입과 프로그램 안정성 [:link:](#10-6-nullable-타입과-프로그램-안정성)

</details>

## 10-1 제네릭 타입 이해하기

### 제네릭 타입

**제네릭 타입**은 인터페이스나, 클래스, 합수, 타입 별칭 등에 사용할 수 있는 기능이다.<br/>
해당 심볼의 타입을 미리 지정하지 않고 다양한 타입에 대응하려고 할 때 사용한다.<br/>

```typescript
interface IValuable<T> {
    value: T;
}
```

위의 `IValueable` 인터페이스는 `T` 타입의 `value` 라는 속성을 갖는다.<br/>
위와 같이 타입을 `string`, `number`등으로 정하지 않고 `T`로 지정해 **제네릭 타입**으로 만들 수 있다.<br/>
**제네릭 타입**을 인터페이서 지정할 때 위와 같이 인터페이스 이름 뒤에 `<T>`와 같이 표기한다.<br/>

```typescript
function identity<T>(arg: T): T {
    return arg;
}

type IValuable<T> = {
    value: T;
};

class Valueable<T> {
    constructor(public value: T) {}
}
```

위의 코드는 클래스와 함수, 타입 별칭에 각각 **제네릭 타입**을 사용하는 예시다.<br/>

### 제네릭 사용하기

아래와 같이 `T` 타입의 `value` 속성을 갖는 `IValuable` 인터페이스를 작성한다.<br/>

-   `IValuable.ts`

```typescript
export interface IValuable<T> {
    value: T;
}
```

제네릭 인터페이스 `IValuable<T>`를 구현하는 **제네릭 클래스**는 타입 변수 `T`를 갖는다.<br>
구현한 **제네릭 클래스**는 가지고 있는 타입 변수를 인터페이스의 제네릭 타입 변수로 넘길 수 있다.<br/>

-   `Valuable.ts`

```typescript
import { IValuable } from "./IValuable";

export class Valuable<T> implements IValuable<T> {
    constructor(public value: T) {}
}

export { IValuable };
```

**제네릭 함수**는 타입 변수 `T`를 제네릭 인터페이스의 타입 변수로 넘기는 형태로 구현할 수 있다.<Br/>

-   `printValue.ts`

```typescript
import { IValuable, Valuable } from "./Valuable";

export const printValue = <T>(o: IValuable<T>): void => console.log(o.value);
export { IValuable, Valuable };
```

이렇게 만든 제네릭 함수 `printValue`는 아래 처럼 다양한 타입을 대상으로 동작할 수 있다.<br/>

-   `printValue-Test.ts`

```typescript
import { printValue, Valuable } from "./PrintValue";

printValue(new Valuable<number>(1)); // 1
printValue(new Valuable<boolean>(true)); // true
printValue(new Valuable<string>("hello")); // hello
printValue(
    new Valuable<number[]>([1, 2, 3])
); // [ 1, 2, 3 ]
```

또한 아래와 같이 타입 변수 부분을 생략해도 스스로 추론해 제네릭 타입을 찾아낸다.<br/>

-   `printValue-Test2.ts`

```typescript
import { printValue, Valuable } from "./PrintValue";

printValue(new Valuable(1)); // 1
printValue(new Valuable(true)); // true
printValue(new Valuable("hello")); // hello
printValue(new Valuable([1, 2, 3])); // [ 1, 2, 3 ]
```

제네릭 타입을 지정하지 않아도 동일한 결과를 출력하는 것을 볼 수 있다.<br/>

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-2 제네릭 타입 제약

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-3 대수 데이터 타입

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-4 타입 가드

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-5 F-바운드 다형성

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-6 nullable 타입과 프로그램 안정성

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
