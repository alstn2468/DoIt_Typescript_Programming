# 10장 제네릭 프로그래밍

<details><summary>Table of Contents</summary>

-   10-1 제네릭 타입 이해하기 [:link:](#10-1-제네릭-타입-이해하기)
    -   제네릭 타입 [:link:](#제네릭-타입)
    -   제네릭 사용하기 [:link:](#제네릭-사용하기)
-   10-2 제네릭 타입 제약 [:link:](#10-2-제네릭-타입-제약)
    -   제네릭 타입 제약 [:link:](#제네릭-타입-제약)
    -   new 타입 제약 [:link:](#new-타입-제약)
    -   인덱스 타입 제약 [:link:](#인덱스-타입-제약)
-   10-3 대수 데이터 타입 [:link:](#10-3-대수-데이터-타입)
-   10-4 타입 가드 [:link:](#10-4-타입-가드)
-   10-5 F-바운드 다형성 [:link:](#10-5-f-바운드-다형성)
-   10-6 nullable 타입과 프로그램 안정성 [:link:](#10-6-nullable-타입과-프로그램-안정성)

</details>

## 10-1 제네릭 타입 이해하기

### 제네릭 타입

**제네릭 타입**은 인터페이스나, 클래스, 합수, 타입 별칭 등에 사용할 수 있는 기능이다.<br/>
해당 심볼의 타입을 미리 지정하지 않고 다양한 타입에 대응하려고 할 때 사용한다.<br/>

```typescript
interface IValuable<T> {
    value: T;
}
```

위의 `IValueable` 인터페이스는 `T` 타입의 `value` 라는 속성을 갖는다.<br/>
위와 같이 타입을 `string`, `number`등으로 정하지 않고 `T`로 지정해 **제네릭 타입**으로 만들 수 있다.<br/>
**제네릭 타입**을 인터페이서 지정할 때 위와 같이 인터페이스 이름 뒤에 `<T>`와 같이 표기한다.<br/>

```typescript
function identity<T>(arg: T): T {
    return arg;
}

type IValuable<T> = {
    value: T;
};

class Valueable<T> {
    constructor(public value: T) {}
}
```

위의 코드는 클래스와 함수, 타입 별칭에 각각 **제네릭 타입**을 사용하는 예시다.<br/>

### 제네릭 사용하기

아래와 같이 `T` 타입의 `value` 속성을 갖는 `IValuable` 인터페이스를 작성한다.<br/>

-   `IValuable.ts`

```typescript
export interface IValuable<T> {
    value: T;
}
```

제네릭 인터페이스 `IValuable<T>`를 구현하는 **제네릭 클래스**는 타입 변수 `T`를 갖는다.<br>
구현한 **제네릭 클래스**는 가지고 있는 타입 변수를 인터페이스의 제네릭 타입 변수로 넘길 수 있다.<br/>

-   `Valuable.ts`

```typescript
import { IValuable } from "./IValuable";

export class Valuable<T> implements IValuable<T> {
    constructor(public value: T) {}
}

export { IValuable };
```

**제네릭 함수**는 타입 변수 `T`를 제네릭 인터페이스의 타입 변수로 넘기는 형태로 구현할 수 있다.<Br/>

-   `printValue.ts`

```typescript
import { IValuable, Valuable } from "./Valuable";

export const printValue = <T>(o: IValuable<T>): void => console.log(o.value);
export { IValuable, Valuable };
```

이렇게 만든 제네릭 함수 `printValue`는 아래 처럼 다양한 타입을 대상으로 동작할 수 있다.<br/>

-   `printValue-Test.ts`

```typescript
import { printValue, Valuable } from "./PrintValue";

printValue(new Valuable<number>(1)); // 1
printValue(new Valuable<boolean>(true)); // true
printValue(new Valuable<string>("hello")); // hello
printValue(
    new Valuable<number[]>([1, 2, 3])
); // [ 1, 2, 3 ]
```

또한 아래와 같이 타입 변수 부분을 생략해도 스스로 추론해 제네릭 타입을 찾아낸다.<br/>

-   `printValue-Test2.ts`

```typescript
import { printValue, Valuable } from "./PrintValue";

printValue(new Valuable(1)); // 1
printValue(new Valuable(true)); // true
printValue(new Valuable("hello")); // hello
printValue(new Valuable([1, 2, 3])); // [ 1, 2, 3 ]
```

제네릭 타입을 지정하지 않아도 동일한 결과를 출력하는 것을 볼 수 있다.<br/>

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-2 제네릭 타입 제약

### 제네릭 타입 제약

**제네릭 타입 제약**은 타입 변수에 적용할 수 있는 **타입의 범위를 제한하는 기능**을 한다.<br/>
Typescript에서 제네릭 함수의 타입을 제한하고 싶을 때는 아래와 같은 구문을 사용한다.<br/>

```typescript
<최종 타입1 extend 타입1, 최종 타입2 extend 타입2>(a: 최종 타입1, b: 최종 타입2, ...) {}
```

아래의 `IValuable<T>`는 `T` 타입 `value` 속성을 갖는 제네릭 인터페이스다.<br/>

-   `IValuable.ts`

```typescript
export interface IValuable<T> {
    value: T;
}
```

아래의 `printValueT` 함수는 앞의 `printValue` 함수와 구현 방식이 조금 다르다.<br/>
`printValueT` 함수는 **제네릭 타입 제약** 구문을 사용해 구현되어 있다.<br/>

-   `printValueT.ts`

```typescript
import { IValuable, Valuable } from "./Valuable";

export const printValueT = <Q, T extends IValuable<Q>>(o: T): void =>
    console.log(o.value);
export { IValuable, Valuable };
```

`printValue`와 비교하여 매개변수의 타입을 어떤 방식으로 제약하는지만 다르다.<br/>

```typescript
import { printValueT } from "./printValueT";
import { Valuable } from "./Valuable";

printValueT(new Valuable(1)); // 1
printValueT({ value: true }); // true
```

출력 결과는 `printValue` 함수를 사용한 것과 동일한 것을 볼 수 있다.<br/>
위의 `printValueT` 함수는 아래와 같이 구현하면 안된다.<br/>

```typescript
export const printValueT = <T extends IValuable<T>>(o: T) =>
    console.log(o.value);
```

`o`의 `T` 입장에서 타입 `T`는 `IValuable<T>`이므로 `IValuable <IValuable<T>>`와 같이 해석되기 때문이다.<br/>

### new 타입 제약

팩토리 함수는 `new` 연산자를 사용해 객체를 생성하는 기능을 하는 함수를 의미한다.<br/>
팩토리 함수는 객체를 생성하는 방법이 복잡할 때 단순화하려는 목적으로 구현한다.<br/>

```typescript
const create = <T>(type: T): T => new type();
```

위 코드에서 `create` 함수의 매개변수 `type`은 실제로 **타입**이다.<br/>
따라서 `type` 변수의 타입 주석으로 명시한 `T`는 **타입의 타입**에 해당한다.<br/>

<img src="./images/1.png" width="350" height="auto">

하지만 Typescript는 타입의 타입을 허용하지 않으므로 위와 같은 오류가 발생한다.<br/>
Typescript의 창시자인 아네르스 하일스베르는 C# 언어의 창시자이기도 하다.<br/>
아래 코드에서 `{new(): T}` 구문은 C#에서 볼 수 있는 구문과 매우 유사하다.<br/>

```typescript
const create = <T extends { new (): T }>(type: T): T => new type();
```

하일스베르는 타입의 타입에 해당하는 구문을 만들지 않고 C# 언어에서의 구문을 빌려 사용하였다.<br/>
`create` 함수의 타입 제약 구문은 `{}`로 `new()` 부분을 감싸서 메서드 형태로 표현했다.<br/>
이 구문은 아래와 같이 `{}`를 없앤 좀 더 간결한 문법으로 표현할 수도 있다.<br/>

```typescript
const create = <T>(type: new () => T): T => new type();
```

결론적으로 `{ new(): T }`와 `new() =>` 는 같은 의미를 갖는다.<br/>
`new` 연산자를 `type`에 적용하며 `type`의 생성자로 인자를 전달하려면 아래와 같이 사용한다.<br/>

```typescript
const create = <T>(type: { new (...args): T }, ...args): T => new type(...args);
```

아래 코드는 `Date`와 `Point` 인스턴스를 **타입 제약**을 설정한 `create`함수로 생성하는 예시다.<br/>

-   `create.ts`

```typescript
export const create = <T>(type: { new (...args): T }, ...args): T =>
    new type(...args);
```

-   `create-Test.ts`

```typescript
import { create } from "./create";

class Point {
    constructor(public x: number, public y: number) {}
}
[create(Date), create(Point, 0, 0)].forEach((s) => console.log(s));
// 2020-07-30T06:16:53.363Z
// Point { x: 0, y: 0 }
```

위의 `create` 함수를 호출해 보면 클래스의 인스턴스가 정상적으로 생성되는 것을 볼 수 있다.<br/>

### 인덱스 타입 제약

객체의 일정 속성들만 추려 좀 더 단순한 객체를 만들어야 할 때가 있다.<br/>
`pick` 함수는 `obj` 객체에서 `name`과 `age` 두 속성만 추출해 간단한 형태를 만드려 한다.<br/>

```typescript
const obj = { name: "Jane", age: 22, city: "Seoul", country: "Korea" };
pick(obj, ["name", "age"]);
```

위에서 사용한 `pick` 함수는 아래와 같이 구현할 수 있다.<br/>

-   `pick.ts`

```typescript
export const pick = (obj, keys) =>
    keys
        .map((key) => ({ [key]: obj[key] }))
        .reduce((result, value) => ({ ...result, ...value }), {});
```

아래의 코드를 실행하면 `pick` 함수가 `name`과 `age` 속성과 값을 추출해주는 것을 볼 수 있다.<br/>

-   `pick-Test.ts`

```typescript
import { pick } from "./pick";

const obj = { name: "Jane", age: 22, city: "Seoul", country: "Korea" };
console.log(pick(obj, ["name", "age"])); // { name: 'Jane', age: 22 }
console.log(pick(obj, ["name", "agge"])); //{ name: 'Jane', agge: undefined }
```

하지만 `pick(obj, ["name", "agge"])`와 같이 오타가 발생하면 엉뚱한 결과가 나온다.<br/>
Typescript는 이러한 상황을 방지하기 위해 `keyof T` 형태로 **타입 제약**을 설정할 수 있다.<br/>
`keyof T` 형태 같은 타입 제약을 **인덱스 타입 제약**이라고 한다.<br/>

```typescript
<T, K extends keyof T>
```

아래 코드에서 `pick` 함수는 `keys` 매개변수에 각각 `T`와 `K`라는 타입 변수를 적용했다.<br/>

```typescript
export const pick = <T, K>(obj: Text, keys: K[]) =>
    keys
        .map((key) => ({ [key]: obj[key] }))
        .reduce((result, value) => ({ ...result, ...value }), {});
```

하지만 이 코드는 `K` 타입에 타입 제약을 설정하지 않았으므로 아래와 같은 오류가 발생한다.<br/>

<img src="./images/2.png" width="400" height="auto"><br/>
<img src="./images/3.png" width="400" height="auto">

위와 같은 오류를 해결하려면 타입 `K`가 `T`의 속성 이름이라는 것을 알려줘야 한다.<br/>
`keyof T` 구문으로 타입 `K`가 타입 `T`의 속성 이름이라고 **인덱스 타입 제약**을 설정한다.<br/>

-   `pickTwo.ts`

```typescript
export const pickTwo = <T, K extends keyof T>(obj: T, keys: K[]) =>
    keys
        .map((key) => ({ [key]: obj[key] }))
        .reduce((result, value) => ({ ...result, ...value }), {});
```

아래 코드를 실행하면 **인덱스 타입 제약**을 설정한 `pickTwo` 함수를 테스트할 수 있다.<br/>

-   `pickTwo-Test.ts`

```typescript
import { pickTwo } from "./pickTwo";

const obj = { name: "Jane", age: 22, city: "Seoul", country: "Korea" };
console.log(pickTwo(obj, ["name", "age"])); // { name: 'Jane', age: 22 }
console.log(pickTwo(obj, ["name", "agge"])); // Error
```

`pickTwo(obj, ["name", "agge"])` 같이 잘못 사용했을때 작성 시점에 오류를 탐지할 수 있다.<br/>

<img src="./images/4.png" width="450" height="auto">

위와 같이 컴파일 이전에 `obj`의 속성이 아닌 `agge`를 사용할 수 없는 것을 볼 수 있다.<br/>

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-3 대수 데이터 타입

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-4 타입 가드

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-5 F-바운드 다형성

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 10-6 nullable 타입과 프로그램 안정성

[[🔝위로가기]](#10장-제네릭-프로그래밍)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
