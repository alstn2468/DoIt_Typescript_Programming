# 05장 배열과 튜플

<details><summary>Table of Contents</summary>

-   05-1 배열 이해하기 [:link:](#05-1-배열-이해하기)
    -   Javascript의 배열 [:link:](#javascript의-배열)
    -   [] 단축 구문 [:link:](#-단축-구문)
    -   배열은 객체다 [:link:](#배열은-객체다)
    -   배열의 타입 [:link:](#배열의-타입)
    -   문자열과 배열 간 변환 [:link:](#문자열과-배열-간-변환)
    -   인덱스 연산자 [:link:](#인덱스-연산자)
    -   배열의 비구조화 할당 [:link:](#배열의-비구조화-할당)
    -   for...in 문 [:link:](#forin-문)
    -   for...of 문 [:link:](#forof-문)
    -   제네릭 방식 타입 [:link:](#제네릭-방식-타입)
    -   제네릭 함수의 타입 추론 [:link:](#제네릭-함수의-타입-추론)
    -   제네릭 함수의 함수 시그니처 [:link:](#제네릭-함수의-함수-시그니처)
    -   전개 연산자 [:link:](#전개-연산자)
    -   range 함수 구현 [:link:](#range-함수-구현)
-   05-2 선언형 프로그래밍과 배열 [:link:](#05-2-선언형-프로그래밍과-배열)
    -   선언형 프로그래밍 [:link:](#선언형-프로그래밍)
    -   명령형 프로그래밍 [:link:](#명령형-프로그래밍)
    -   1부터 100까지 더하기 [:link:](#1부터-100까지-더하기)
    -   fold: 배열 데이터 접기 [:link:](#fold-배열-데이터-접기)
    -   1에서 100까지 홀수의 합 구하기 [:link:](#1에서-100까지-홀수의-합-구하기)
    -   filter: 조건에 맞는 아이템만 추려내기 [:link:](#filter-조건에-맞는-아이템만-추려내기)
    -   1에서 100까지 짝수의 합 구하기 [:link:](#1에서-100까지-홀수의-합-구하기)
    -   1² + 2² + ... + 100² 구하기 [:link:](#1²--2²----100²-구하기)
    -   map: 배열 데이터 가공하기 [:link:](#map-배열-데이터-가공하기)
-   05-3 배열의 map, reduce, filter 메서드 [:link:](#05-3-배열의-map-reduce-filter-메서드)
-   05-4 순수 함수와 배열 [:link:](#05-4-순수-함수와-배열)
-   05-5 튜플 이해하기 [:link:](#05-5-튜플-이해하기)

</details>

## 05-1 배열 이해하기

### Javascript의 배열

Javasript에서 배열은 `Array` 클래스의 인스턴스이며 아래와 같이 선언한다.<br/>

```javascript
let 배열 이름 = new Array(배열 길이)
```

아래와 같이 `Array` 인스턴스를 만들고 `push` 메서드를 이용해 배열에 값을 넣을 수 있다.<br/>

```javascript
let array = new Array();

array.push(1);
array.push(2);
array.push(3);

console.log(array); // [ 1, 2, 3 ]
```

배열에 담간 각각의 값을 **아이템** 또는 **원소**라고 하며 위의 `array`에는 3개의 아이템이 있다.<br/>

### [] 단축 구문

`new` 연산자를 이용해 `Array`클래스의 인스턴스를 생성해 배열을 만드는 것은 번거롭다.<br/>
따라서 Javascript는 `[]`라는 단축 구문으로 배열을 생성할 수 있다.<br/>

-   `[]` 단축 구문을 이용한 배열 생성 예시

```typescript
let numbers = [1, 2, 3];
let strings = ['Hello', 'World!'];

console.log(numbers, strings); // [ 1, 2, 3 ] [ 'Hello', 'World!' ]
```

위의 코드는 `[]` 단축 구문을 이용해 `numbers` 배열과 `strings` 배열을 생성하는 예시다.<br/>

### 배열은 객체다

Javascript에서의 **배열은** 다른 언어와 다르게 **객체다**.<br/>
**배열**은 `Array` 클래스의 **인스턴스**인데 **인스턴스는 객체**이기 때문에 **배열은 객체다**.<br/>
`Array` 클래스는 배열을 사용하는데 필요한 **여러 가지 메서드를 제공**한다.<br/>

-   `Array` 클래스의 메서드 예시

```typescript
let a = [1, 2, 3];
let o = { name: 'Jack', age: 32 };

console.log(Array.isArray(a), Array.isArray(o)); // true false
```

위의 코드의 `isArray` 메서드는 **인자로 받은 심벌**이 **배열인지 확인**하는 메서드다.<br/>

### 배열의 타입

Typescript에서 배열의 타입은 `아이템 타입[]`이다.<br/>
배열의 아이템이 `number` 타입이면 배열의 타입은 `number[]`고 `string`이면 `string[]`이다.<br/>

-   **배열에 타입 주석**을 붙이는 예시

```typescript
let numArray: number[] = [1, 2, 3];
let strArray: string[] = ['Hello', 'World'];

type IPerson = { name: string; age?: number };
let personArray: IPerson[] = [{ name: 'Jack' }, { name: 'Jane', age: 32 }];
```

`number`타입과 `string`타입과 마찬가지로 `IPerson`과 같은 직접 선언한 타입 또한 가능하다.<br/>

### 문자열과 배열 간 변환

어떤 언어에서는 **문자열**(**String**)을 **문자**(**Character**)들의 **배열**로 간주한다.<br/>
Typescript에서는 **문자**(**Character**) 타입은 없고 **문자열**(**String**)의 내용은 변경할 수 없다.<br/>
이런 특징 때문에 **문자열을 가공**하기 위해서는 **문자열을 배열로 전환**해야 한다.<br/>
문자열을 배열로 전환할 때는 `String` 클래스의 `split` 메서드를 사용한다.<br/>

-   `split` 메서드 사용법

```typescript
split(구분자: string): string[]
```

-   `String`의 `split` 메서드를 이용해 구현한 `split` 함수

`split` 함수는 전달받은 **문자열**과 **구분자**를 이용해 **문자열을 문자열 배열을 반환**한다.<br/>

```typescript
const split = (str: string, delim: string = ''): string[] => str.split(delim);

console.log(split('Hello')); // [ 'H', 'e', 'l', 'l', 'o' ]
console.log(split('H_e_l_l_o', '_')); // [ 'H', 'e', 'l', 'l', 'o' ]
```

문자열을 `delim` 구분자를 이용해 문자열을 나누어 **배열로 반환**하는 것을 확인할 수 있다.<br/>
문자열 배열을 `string`타입으로 변환하기 위해서는 `Array`의 `join` 메서드를 사용한다.<br/>

-   `join` 메서드 사용법

```typescript
join(구분자: string): string
```

-   `Array`의 `join` 메서드를 이용해 구현한 `join` 함수

`join` 함수는 전달받은 **문자열 배열**과 **구분자**를 **결합해 새로운 문자열을 반환**한다.<br/>

```typescript
const join = (strArray: string[], delim: string = ''): string =>
    strArray.join(delim);

console.log(join(['H', 'e', 'l', 'l', 'o'])); // Hello
console.log(join(['H', 'e', 'l', 'l', 'o'], '_')); // H_e_l_l_o
```

**문자열 배열**에 있는 모든 **문자열**을 `delim` **구분자를 이용해 결합**해 반환하는 것을 확인할 수 있다..<br/>

### 인덱스 연산자

배열의 아이템 중 특정 위치에 있는 아이템을 얻고자 할 때 **인덱스 연산자**를 사용한다.<br/>
**인덱스 연산자**는 `배열명[인덱스]`처럼 사용하며 **배열의 특정 위치의 아이템**을 얻을 수 있다.<br/>

-   배열의 **인덱스 연산자** 예시

```typescript
const numbers: number[] = [1, 2, 3, 4, 5];

for (let index = 0; index < numbers.length; index++) {
    const item: number = numbers[index];
    console.log(item); // 1 2 3 4 5
}
```

위의 코드의 `numbers[index]`와 같이 `numbers`배열의 **특정 위치의 값**을 얻을 수 있다.<br/>

### 배열의 비구조화 할당

객체뿐만 아니라 배열에도 **비구조화 할당**을 적용할 수 있다.<br/>
배열의 **비구조화 할당**에는 객체와 달리 `[]` 기호를 사용한다.<br/>

-   배열의 **비구조화 할당** 예시

```typescript
let array: number[] = [1, 2, 3, 4, 5];
let [first, second, third, ...rest] = array;
console.log(first, second, third, rest); // 1 2 3 [ 4, 5 ]
```

`[]`기호를 사용하는 것을 제외하고 객체의 **비구조화 할당**과 동일하게 작동한다.<br/>

### for...in 문

ESNext와 Typescript는 `for`문을 더 쉽게 사용하도록 `for...in`문을 제공한다.<br/>
`for...in` 문은 객체를 대상으로 사용하지만 배열 또한 객체이기 때문에 사용할 수 있다.<br/>

-   `for...in`문 문법

```typescript
for (let 변수 in 객체) {
    ...
}
```

-   배열에서의 `for...in`문 예시

```typescript
let names = ['Jack', 'Jane', 'Steve'];

for (let index in names) {
    const name = names[index];
    console.log(`[${index}]: ${name}`); // [0]: Jack [1]: Jane [2]: Steve
}
```

배열에서의 `for...in`문은 **배열의 인덱스**값을 순회한다.<br/>

-   객체에서의 `for...in`문 예시

```typescript
let jack = { name: 'Jack', age: 32 };

for (let property in jack) {
    console.log(`${property}: ${jack[property]}`); // name: Jack age: 32
}
```

객체에서의 `for...in`문은 객체가 가진 **속성**을 대상으로 순회한다.<br/>

### for...of 문

ESNext와 Typescript는 `for...in`문과 사용법이 약간 다른 `for...of`문도 제공한다.<br/>

-   `for...of`문 문법

```typescript
for (let 변수 of 객체) {
    ...
}
```

-   배열에서의 `for...of`문 예시

```typescript
let names = ['Jack', 'Jane', 'Steve'];

for (let name of names) {
    console.log(name); // Jack Jane Steve
}
```

배열에서의 `for...of`문은 인덱스가 아닌 배열의 **아이템값**을 대상으로 순회한다.<br/>

-   객체에서의 `for...of`문 예시

```typescript
let jack = { name: 'Jack', age: 32 };

// Type '{ name: string; age: number; }' is not an array type or a string type
for (let name of jack) {
    console.log(name);
}
```

<img src="./images/1.png" width="500" height="auto">

`for...in`문과 다르게 `for...of`문은 `object`타입에는 사용할 수 없다.<br/>

### 제네릭 방식 타입

배열을 다루는 함수를 작성할 때 아이템 타입을 `T[]`로 한꺼번에 표현하는 것이 편리하다.<br/>
**타입을 T와 같은 일종의 변수로 취급**하는 것을 **제네릭**(**Generics**) 타입 이라고 한다.<br/>

-   Typescript의 **제네릭**을 사용하는 예시

```typescript
const arrayLength = (array) => array.length;
```

위의 `arrayLength` 함수는 배열의 길이를 얻는 함수로 Javascript로 구현되었다.<br/>
이 함수가 다양한 타입에 적용되게 하려면 **배열의 타입 주석**을 `T[]`로 표현한다.<br/>

```typescript
const arrayLength = (array: T[]): number => array.length;
```

이렇게 작성하게 되면 컴파일러가 `T`가 타입 변수임을 알아야 한다.<br/>
아래와 같이 함수의 매개변수 앞에 `<T>`를 추가해 작성할 수 있다.<br/>

```typescript
const arrayLength = <T>(array: T[]): number => array.length;
const isEmpty = <T>(array: T[]): boolean => arrayLength<T>(array) == 0;

let numArray: number[] = [1, 2, 3];
let strArray: string[] = ['Hello', 'World'];

type IPerson = { name: string; age?: number };
let personArray: IPerson[] = [{ name: 'Jack' }, { name: 'Jane', age: 32 }];

console.log(arrayLength(numArray)); // 3
console.log(arrayLength(strArray)); // 2
console.log(arrayLength(personArray)); // 2
console.log(isEmpty([])); // true
console.log(isEmpty([1])); // false
```

**제네릭 타입**으로 함수가 구현되었기 때문에 위와 같이 여러 타입에 적용이 가능하다.<br/>

### 제네릭 함수의 타입 추론

아래 코드의 `identity` 함수는 **제네릭** 형태로 구현되었다.<br/>

```typescript
const identity = <T>(n: T): T => n;
console.log(identity<boolean>(true)); // true
console.log(identity(true)); // true
```

**제네릭** 형태로 구현된 함수는 원칙적으로 아래와 같이 **타입 변수를 명시**해야 한다.<br/>

```typescript
함수 이름<타입 변수>(매개변수)
```

Typescript는 `identity(true)`와 같이 **타입 변수를 생략**할 수 있게 한다.<br/>
Typescript는 **타입 변수가 생략된 제네릭 함수**를 만나면 **타입 추론**을 통해 타입을 찾는다.<br/>

### 제네릭 함수의 함수 시그니처

Typescript는 어떤 경우 **함수 시그니처의 매개변수** 부분에 **변수 이름을 기입**하라고 요구한다.<br/>

```typescript
const normal = (cb: (number) => number): void => {};
const error = (cb: (number, number?) => number): void => {};
const fixed = (cb: (a: number, number?) => number): void => {};
```

위의 코드에서 `normal` 함수는 `cb` 매개변수에 함수 시그니처를 사용했다.<br/>
`normal`과 비슷하게 `error` 함수 역시 `cb` 매개변수에 함수 시그니쳐를 사용했다.<br/>
하지만 `normal`과 다르게 `error`에서는 아래와 같은 오류가 발생하는 것을 확인할 수 있다.<br/>

<img src="./images/2.png" width="300" height="auto">

이 경우 `fixed` 선언문 처럼 해석하지 못하는 부분에 **변수와 변수 타입을 명시**해 해결한다.<br/>
제네릭 타입의 함수에서도 같은 문제가 발생하며 `fixed`와 동일하게 해결한다.<br/>

```typescript
const f = <T>(cb: (arg: T, i?: number) => number): void => {};
```

### 전개 연산자

**전개 연산자**는 점 세개가 나란히 있는 `...` 연산자를 의미한다.<br/>
객체와 동일하게 배열에도 **전개 연산자**를 적용할 수 있다.<br/>

-   배열에서의 **전개 연산자** 사용 예시

```typescript
let array1: number[] = [1];
let array2: number[] = [2, 3];
let mergedArray: number[] = [...array1, ...array2, 4];
console.log(mergedArray); // [ 1, 2, 3, 4 ]
```

### range 함수 구현

앞에서 `ramda`라는 외부 패키지가 제공하는 `R.range` 함수를 사용했었다.<br/>
배열에 **전개 연산자**를 적용하면 `R.range`와 같은 함수를 쉽게 만들 수 있다.<br/>

-   **전개 연산자**를 적용해 구현한 `range` 함수

```typescript
const range = (from: number, to: number): number[] =>
    from < to ? [from, ...range(from + 1, to)] : [];

let numbers: number[] = range(1, 9 + 1);
console.log(numbers); // [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
```

위의 `range` 함수는 재귀 함수로 동작하며 `from`에서 `to`까지의 수의 배열을 생성한다.<br/>

[[🔝위로가기]](#05장-배열과-튜플)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 05-2 선언형 프로그래밍과 배열

### 선언형 프로그래밍

### 명령형 프로그래밍

### 1부터 100까지 더하기

### fold: 배열 데이터 접기

### 1에서 100까지 홀수의 합 구하기

### filter: 조건에 맞는 아이템만 추려내기

### 1에서 100까지 짝수의 합 구하기

### 1² + 2² + ... + 100² 구하기

### map: 배열 데이터 가공하기

[[🔝위로가기]](#05장-배열과-튜플)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 05-3 배열의 map, reduce, filter 메서드

[[🔝위로가기]](#05장-배열과-튜플)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 05-4 순수 함수와 배열

[[🔝위로가기]](#05장-배열과-튜플)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 05-5 튜플 이해하기

[[🔝위로가기]](#05장-배열과-튜플)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
