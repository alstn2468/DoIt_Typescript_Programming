# 08장 함수 조합의 원리와 응용

<details><summary>Table of Contents</summary>

-   08-1 함수형 프로그래밍이란? [:link:](#08-1-함수형-프로그래밍이란)
    -   함수형 프로그래밍 [:link:](#함수형-프로그래밍)
    -   함수형 프로그래밍 언어의 기능 [:link:](#함수형-프로그래밍-언어의-기능)
    -   함수형 프로그래밍 언어의 발전 [:link:](#함수형-프로그래밍-언어의-발전)
-   08-2 제네릭 함수 [:link:](#08-2-제네릭-함수)
    -   Typescript의 제네릭 함수 구문 [:link:](#typescript의-제네릭-함수-구문)
    -   함수의 역할 [:link:](#함수의-역할)
    -   아이덴티티 함수 [:link:](#아이덴티티-함수)
-   08-3 고차 함수와 커리 [:link:](#08-3-고차-함수와-커리)
    -   함수형 프로그래밍에서의 함수의 조합 [:link:](#함수형-프로그래밍에서의-함수의-조합)
    -   고차 함수란? [:link:](#고차-함수란)
    -   부분 적용 함수와 커리 [:link:](#부분-적용-함수와-커리)
    -   클로저 [:link:](#클로저)
-   08-4 함수 조합 [:link:](#08-4-함수-조합)
    -   함수 조합 [:link:](#함수-조합)
    -   compose 함수 [:link:](#compose-함수)
    -   pipe 함수 [:link:](#pipe-함수)
    -   pipe와 compose 함수 분석 [:link:](#pipe와-compose-함수-분석)
    -   부분 함수와 함수 조합 [:link:](#부분-함수와-함수-조합)
    -   포인트가 없는 함수 [:link:](#포인트가-없는-함수)

</details>

## 08-1 함수형 프로그래밍이란?

### 함수형 프로그래밍

**함수형 프로그래밍**은 **순수 함수**와 **선언형 프로그래밍**을 토대로한다.<br/>
또한 **함수 조합**과 **모나드 조합**으로 코드를 설계하고 구현하는 기법이다.<br/>
**함수형 프로그래밍**은 아래의 세 가지 수학 이론에 기반을 두고 있다.<br/>

1. **람다 수학** : **조합 논리**와 **카테고리 이론**의 토대가 되는 논리 수학

2. **조합 논리** : **함수 조합**의 이론적 배경

3. **카테고리 이론** : **모나드 조합**과 **고차 타입**의 이론적 배경

### 함수형 프로그래밍 언어의 기능

**함수형 프로그래밍** 언어는 아래의 기능들을 제공할 수 있다.<br/>

1. 정적 타입 (Static Type)
2. 자동 메모리 관리 (Automatic Memory Management)
3. 계산법 (Evaluation)
4. 타입 추론 (Type Inteface)
5. 일등 함수 (First-class Function)
6. 대수 데이터 타입 (Algebraic Data Type)
7. 패턴 매칭 (Pattern Matching)
8. 모나드 (Monad)
9. 고차 타입 (High Order Type)

다만 **함수형 언어**라고 해서 위의 **모든 기능을 제공하는 것은 아니다**.<br/>

### 함수형 프로그래밍 언어의 발전

**함수형 프로그래밍 언어**는 한때 인공지능의 언어로 불렸던 LISP에 기반을 두고 있다.<br/>
LISP은 메타 언어로 진화되었으며 메타 언어는 다시 하스켈 언어로 발전되었다.<br/>
하스켈 언어는 스칼라 언어에 의해 개발자들에게 친숙한 C언어와 비슷한 구문으로 발전했다.<br/>
Typescript는 스칼라 언어의 구문을 Javascript 친화적으로 발전시키게 되었다.<br/>
Typescript는 함수형 언어에서 중요하게 여겨지는 **패턴 매칭**과 **고차 타입** 기능을 생략했다.<br/>
따라서 다른 언어에서 **어렵게 느껴지는 기능이 생략**되어 **쉬운 함수형 프로그래밍 언어**라고 볼 수 있다.<br/>

[[🔝위로가기]](#08장-함수-조합의-원리와-응용)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 08-2 제네릭 함수

### Typescript의 제네릭 함수 구문

Typescript의 함수는 매개변수와 반환값에 타입이 존재한다.<br/>
따라서 **함수 조합**을 구현하기 위해서는 **제네릭 함수 구문**을 사용해야 한다.<br/>
Typescript에서 **제네릭 타입**은 **함수**, **인터페이스**, **클래스**, **타입 별칭**에 적용할수 있다.<br/>
**제네릭 타입**은 꺽쇠 괄호 `<>`로 타입을 감싼 `<T>`, `<T, Q>`와 같이 표현한다.<br/>

-   `function` 키워드로 만든 함수에 **제네릭 타입**을 적용한 예시

```typescript
function g1<T>(a: T): void {}
function g2<T, Q>(a: T, b: Q): void {}
```

위와 같이 **제네릭 타입**으로 함수를 정의하면 어떠한 타입에도 대응할 수 있다.<br/>
`g1` 함수는 `a` 변수가 **제네릭 타입**으로 지정되었다.<br/>
`g2` 함수는 `a`, `b` 매개변수가 다른 **제네릭 타입**으로 지정되었다.<br/>
`function` 키워드로 만든 함수와 마찬가지로 `=>` 구문을 이용한 **화살표 함수**에도 동일하게 적용할 수 있다.<br/>

-   **화살표 함수**에 **제네릭 타입**을 적용한 예시

```typescript
const g3 = <T>(a: T): void => {};
const g4 = <T, Q>(a: T, b: Q): void => {};
```

함수가 아닌 **타입 별칭**에도 **제네릭 타입**을 적용할 수 있다.<br/>

-   **타입 별칭**에 **제네릭 타입**을 적용한 예시

```typescript
type Type1Func<T> = (T) => void;
type Type2Func<T, Q> = (T, Q) => void;
type Type3Func<T, Q, R> = (T, Q) => R;
```

`Type3Func` 함수의 시그니처는 `T`와 `Q`를 입력받아 `Q`를 반환하는 것을 나타낸다.<br/>

### 함수의 역할

수학에서의 함수는 값 `x`에 수식을 적용해 또 다른 값 `y`를 만드는 역할을 한다.<br/>
함수를 `f`라고 표기하면 `x`, `y`, `f`간의 관계를 아래처럼 표현할 수 있다.<br/>

```typescript
x ~> f ~> y
```

프로그래밍 언어로 수학의 함수를 구현할 때는 변수 `x`와 `y`의 타입을 고려해야 한다.<br/>
함수 `f`가 `T` 타입의 값인 `x`로 `R` 타입의 값인 `y`를 만든다고 하면 아래와 같이 표현할 수 있다.<br/>

```typescript
(x: T) ~-> f -> (y: R)
```

수학에서는 이런 관계를 **일대일 관계**라고 한며 이런 동작을 하는 함수 `f`를 `map`이라고 표현한다.<br/>
Typescript로 `map` 함수를 만든다면 타입 `T`으로 타입 `R`인 값을 만드는 함수 시그니처는 아래와 같다.<br/>

```typescript
type MapFunc<T, R> = (T) => R;
```

### 아이덴티티 함수

`map` 함수의 가장 단순한 형태는 입력값인 `x`를 가공 없이 그대로 반환하는 것이다.<br/>
**함수형 프로그래밍**에서 이러한 역할을 하는 함수 이름에는 보통 `identity` 혹은 `I`라는 단어가 포함된다.<br/>
`MapFunc` 타입을 사용해 **아이덴티티 함수**의 시그니처를 표현하면 아래와 같다.<br/>

```typescript
type MapFunc<T, R> = (T) => R;
type IdentityFunc<T> = MapFunc<T, T>;
```

이렇게 정의한 **제네릭 함수 타입**인 `IdentityFunc<T>`는 아래 같이 다양한 함수를 선언할 때 사용가능하다.<br/>

```typescript
const numberIdentity: IdentityFunc<number> = (x: number): number => x;
const stringIdentity: IdentityFunc<string> = (x: string): string => x;
const objectIdentity: IdentityFunc<object> = (x: object): object => x;
const arrayIdentity: IdentityFunc<any[]> = (x: any[]): any[] => x;
```

[[🔝위로가기]](#08장-함수-조합의-원리와-응용)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 08-3 고차 함수와 커리

### 함수형 프로그래밍에서의 함수의 조합

함수에서 매개변수의 개수를 **애리티**라고 한다.<br/>
`f()`는 **애리티**가 0인 함수이고 `f(x)`는 **애리티**가 1인 함수다.<br/>
만약 함수 `f`, `g`, `h` 모두가 **애리티**가 1이라면 아래와 같이 연결해 사용할 수 있다.<br/>

```typescript
x ~> f ~> g ~> h ~> y
```

위의 내용을 프로그래밍 언어로 표현하면 아래와 같다.<br/>

```typescript
y = h(g(f(x)));
```

함수형 프로그래밍에서는 `compose`나 `pipe`라는 이름의 함수를 사용할 수 있다.<br/>
이 함수들은 `compose(h, g, f)`나 `pipe(f, g, h)`와 같이 **함수들을 조합**해 새로운 함수를 만든다.<br/>
`compose`나 `pipe`의 동작 원리를 이해하기 위해서는 **고차함수**가 무엇인지 알아야 한다.<br/>

### 고차 함수란?

Typescript에서 **함수**는 변수에 담긴 **함수 표현식**이라는 **일종의 값**이다.<br/>
따라서 Typescript에서는 **함수의 반환값으로 함수를 사용**할 수 있다.<br/>
이와 같이 **어떤 함수가 또 다른 함수를 반환**할 때 그 함수를 **고차 함수**라고 한다.<br/>
이 관점에서 함수가 아닌 단순한 값을 반환하는 함수를 **1차 함수**라고 한다.<br/>
1차 함수를 반환하는 함수는 **2차 고차 함수**, 2차 함수를 반환하는 함수는 **3차 고차 함수**라고 한다.<br/>
**1차 함수**, **2차 고차 함수**, **3차 고차 함수**를 함수 시그니처로 표현하면 아래와 같다.<br/>

```typescript
export type FirstOrderFunc<T, R> = (T) => R;
export type SecondOrderFunc<T, R> = (T) => FirstOrderFunc<T, R>;
export type ThirdOrderFunc<T, R> = (T) => SecondOrderFunc<T, R>;
```

위의 함수 시그니처를 참조하는 실제 함수는 아래와 같이 작성할 수 있다.<br/>

```typescript
import { FirstOrderFunc } from './FunctionSignature';

export const inc: FirstOrderFunc<number, number> = (x: number): number => x + 1;
```

`inc` 함수는 단순히 `number` 타입의 값을 반환하므로 **1차 함수**다.<br/>

```typescript
import { inc } from './FirstOrderFunc';

console.log(inc(1)); // 2
```

`inc`는 단순히 함수이므로 `inc(1)`과 같이 호출하는 것이 당연하다.<br/>
하지만 **고차 함수** 관점에서 **1차 함수**이므로 `()` 연산자를 한 번 사용한다 생각할 수 있다.<br/>
반면에 아래의 `add` 함수는 `FirstOrderFunc<number, number>`를 반환하므로 **2차 고차 함수**다.<br/>

```typescript
import { FirstOrderFunc, SecondOrderFunc } from './FunctionSignature';

export const add: SecondOrderFunc<number, number> = (
    x: number
): FirstOrderFunc<number, number> => (y: number): number => x + y;
```

`add`와 같은 **2차 고차 함수**는 아래와 같이 사용할 수 있다.<br/>

```typescript
import { add } from './SecondOrderFunc';

console.log(add(1)(2)); // 3
```

**2차 고차 함수**를 호출할 때는 `add(1)(2)` 처럼 `()` 연산자를 두 번 연속해서 사용한다.<br/>
**함수형 프로그래밍 언어**에서는 이를 **커리**(**Curry**)라고 한다.<br/>
아래의 `add3` 함수는 `SecondOrderFunc<number, number>`를 반환하므로 **3차 고차 함수**다.<br/>

```typescript
import {
    FirstOrderFunc,
    SecondOrderFunc,
    ThirdOrderFunc,
} from './FunctionSignature';

export const add3: ThirdOrderFunc<number, number> = (
    x: number
): SecondOrderFunc<number, number> => (
    y: number
): FirstOrderFunc<number, number> => (z: number): number => x + y + z;
```

**3차 고차 함수**일 때는 아래와 같이 `()` 연산자를 세 번 이어붙여 호출한다.<br/>

```typescript
import { add3 } from './ThirdOrderFunc';

console.log(add3(1)(2)(3)); // 6
```

### 부분 적용 함수와 커리

`add(1)(2)`나 `add3(1)(2)(3)`과 같이 **고차 함수**들은 자신의 차수만큼 `()`연산자를 사용한다.<br/>
`add(1)`이나 `add3(1)(2)` 처럼 차수보다 `()` 연산자를 적게 쓰는 것을 **부분 적용 함수**라고 한다.<br/>
**2차 고차 함수** `add`의 시그니처는 `FirstOrderFunc<number, number>`이므로 `add1` 함수를 만들 수 있다.<br/>

```typescript
import { add3 } from './ThirdOrderFunc';
import { FirstOrderFunc, SecondOrderFunc } from './FunctionSignature';

const add2: SecondOrderFunc<number, number> = add3(1);
const add1: FirstOrderFunc<number, number> = add2(2);

console.log(add1(3)); // 6
console.log(add2(2)(3)); // 6
console.log(add3(1)(2)(3)); // 6
```

`add1` 함수는 `add2(2)`와 같으므로 `add2(2)(3)`처럼 호출할 수도 있다.<br/>
마찬가지로 `add2` 함수는 `add3(1)`이므로 `add3(1)(2)(3)`과 같이 호출할 수 있다.<br/>

### 클로저

**고차 함수**의 몸통에서 선언되는 변수들은 **클로저**(**Closure**)라는 유효 범위를 갖는다.<br/>
아래의 코드의 `return x + y` 부분은 `add` 함수가 반환하는 함수의 반환문이다.<br/>
이 함수는 자신의 바깥쪽 유효 범위에 있는 변수 `x`를 참조하고 있다.<br/>

```typescript
function add(x: number): (number) => number {
    return function (y: number): number {
        return x + y;
    };
}
```

`add`가 반환하는 함수의 내부 범위만 보면 `x`는 이해할 수 없는 변수다.<br/>
이와 같이 범위 안에서는 그 의미를 알 수 없는 변수를 **자유 변수**라고 한다.<br/>
Typescript는 이와 같이 **자유 변수**가 있으면 그 **변수의 바깥쪽 유효 범위에서 선언문을 찾는다**.<br/>
바깥쪽 유효범위에서 `x`의 의미인 `(x: number)`를 알 수 있으므로 정상적으로 컴파일 한다.<br/>
**클로저**는 아래와 같이 `add` 함수를 호출해도 변수 `x`가 메모리에서 해제되지 않는다.<br/>

```typescript
const add1 = add(1);
```

자유 변수인 `x`는 다음 코드가 실행되어야 비로소 메모리가 해제된다.<br/>

```typescript
const result = add1(2);
```

자유 변수의 메모리는 **고차 함수**가 **부분 함수**가 아닌 **값**을 발생해야 해제된다.<br/>
이와 같이 값이 발생될 때 **자유 변수의 메모리가 해제되는 유효 범위**를 **클로저**라고 한다.<br/>
**클로저**는 메모리가 해제되지 않고 프로그램이 끝날 때까지 지속될 수도 있다.<br/>
아래의 `makeNames` 함수는 `() => string` 타입의 함수를 반환하는 **2차 고차 함수**다.<br/>

```typescript
const makeNames = (): (() => string) => {
    const names: string[] = ['Jack', 'Jane', 'Smith'];
    let index = 0;

    return (): string => {
        if (index == names.length) {
            index = 0;
        }

        return names[index++];
    };
};

const makeName: () => string = makeNames();
console.log([1, 2, 3, 4, 5, 6].map(() => makeName()));
// [ 'Jack', 'Jane', 'Smith', 'Jack', 'Jane', 'Smith' ]
```

`makeName` 함수를 호출하면 `() => string` 타입의 함수를 얻을 수 있다.<br/>
`makeNames` 함수에는 원형 리스트 방식으로 동작하는 `names`와 `index`라는 **자유 변수**가 있다.<br/>
`index`는 `names.length`와 값이 같아지면 다시 `0`이 된다.<br/>
따라서 `makeName` 함수를 사용하는 한 `makeNames`에 할당된 **클로저는 해제되지 않는다**.<br/>

[[🔝위로가기]](#08장-함수-조합의-원리와-응용)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 08-4 함수 조합

### 함수 조합

### compose 함수

### pipe 함수

### pipe와 compose 함수 분석

### 부분 함수와 함수 조합

### 포인트가 없는 함수

[[🔝위로가기]](#08장-함수-조합의-원리와-응용)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
