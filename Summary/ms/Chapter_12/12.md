# 12장 프로젝트 실습

<details><summary>Table of Contents</summary>

-   12-1 빅데이터 배치 프로그램 만들기 [:link:](#12-1-빅데이터-배치-프로그램-만들기)
    -   실습 프로젝트 구성 [:link:](#실습-프로젝트-구성)
    -   CSV 파일과 생성기 [:link:](#csv-파일과-생성기)
    -   node.js에서 프로그램 명령 줄 인수 읽기 [:link:](#nodejs에서-프로그램-명령-줄-인수-읽기)
    -   파일 처리 비동기 함수를 Promise로 구현하기 [:link:](#파일-처리-비동기-함수를-promise로-구현하기)
    -   그럴듯한 가짜 데이터 만들기 [:link:](#그럴듯한-가짜-데이터-만들기)
    -   Object.keys와 Object.values 함수 사용하기 [:link:](#objectkeys와-objectvalues-함수-사용하기)
    -   CSV 파일 만들기 [:link:](#csv-파일-만들기)
    -   데이터를 CSV 파일에 쓰기 [:link:](#데이터를-csv-파일에-쓰기)
    -   zip 함수 만들기 [:link:](#zip-함수-만들기)
    -   생성기 코드를 구현할 때 주의할 점 [:link:](#생성기-코드를-구현할-때-주의할-점)
    -   CSV 파일 데이터 읽기 [:link:](#csv-파일-데이터-읽기)
-   12-2 몽고DB에 데이터 저장하기 [:link:](#12-2-몽고db에-데이터-저장하기)
-   12-3 익스프레스로 API 서버 만들기 [:link:](#12-3-익스프레스로-api-서버-만들기)
-   12-4 리액트와 부트스트랩으로 프론트엔드 웹 만들기 [:link:](#12-4-리액트와-부트스트랩으로-프론트엔드-웹-만들기)

</details>

## 12-1 빅데이터 배치 프로그램 만들기

### 실습 프로젝트 구성

이 프로젝트에서는 `node.js`의 `fs` 패키지를 사용하므로 `@types/node` 패키지를 설치한다.<br/>
아래의 명령어를 실행해 `package.json` 파일을 생성하고 패키지를 설치한다.<br/>

```shell
> npm init --y
> npm i -D typescript ts-node @types/node
```

폴더를 생성하고 삭제하는 기능을 구현하기 위해 아래의 두 패키지를 설치한다.<br/>

```shell
> npm i -S mkdirp rimraf
> npm i -D @types/mkdirp @types/rimraf
```

또한 가짜 데이터를 만들어주는 `chance` 패키지를 설치한다.<br/>

```shell
> npm i -S chance
> npm i -D @types/chance
```

`tsconfig.json` 파일은 아래와 같이 설정한다.<br/>

```json
{
    "compilerOptions": {
        "module": "CommonJS",
        "esModuleInterop": true,
        "target": "es5",
        "moduleResolution": "node",
        "outDir": "dist",
        "baseUrl": ".",
        "sourceMap": true,
        "downlevelIteration": true,
        "noImplicitAny": false,
        "paths": {
            "*": ["node_modules/*"]
        }
    },
    "include": ["src/**/*"]
}
```

아래와 같이 프로젝트에 필요한 폴더들을 생성해준다.<br/>

```shell
> mkdir -p src/fileApi
> mkdir src/fake
> mkdir src/csv
> mkdir src/utils
> mkdir src/test
```

### CSV 파일과 생성기

Javascript나 Typescript는 파일에 데이터를 저장할 때 주로 `JSON` 포맷을 사용한다.<br/>
하지만 저장할 데이터의 양이 많아지면 `JSON`파일 포맷은 시스템 메모리를 많이 사용한다.<br/>
따라서 데이터를 파일에 저장할 때는 `JSON`처럼 나중에 읽기 쉬운 형식으로 만든다.<br/>
보통 테이블 형태의 데이터는 파일 확장자가 `csv`인 파일에 저장한다.<br/>
CSV 파일은 데이터가 아래와 같은 형식으로 저장된 파일을 말한다.<br/>

```csv
name,email,ip,phone
Leona Alexander,ikefo@ved.ws,32.133.3.226,(502) 739-6533
```

CSV 파일 형식은 맨 첫 줄의 헤더 정보에 데이터를 나타내는 이름을 `,`로 구분한다.<br/>
그 다음 줄부터는 각 이름에 해당하는 데이터를 똑같이 `,`로 구분해 놓을 수 있다.<br/>
또한 CSV파일은 JSON파일과 달리 데이터를 한꺼번에 읽지 않고 한줄 씩 읽는다.<br/>
**생성기**는 시스템 자원을 매우 적게 소모하며 엄청난 분량의 데이터를 처리할 수 있도록 한다.<br/>
CSV파일을 한 줄씩 읽으며 Typescript 객체로 변환한 후 `yield`문으로 넘겨줄 수 있다.<br/>
`for...of` 구문으로 `yield`문으로 넘겨받은 하나의 객체를 대상으로 작업을 진행한다.<br/>

### node.js에서 프로그램 명령 줄 인수 읽기

`node.js` 프로그램을 실행하면 아래처럼 실행 명령 뒤에 여러 개의 매개변수를 입력할 수 있다.<br/>

```shell
> ts-node src/test/processArgs-test.ts data/fake.csv 100000
```

이와 같이 프로그램을 실행할 때 외부에서 입력된 값을 **명령 줄 인수**라고 한다.<br/>
`node.js`가 제공하는 `process` 내장 객체의 `argv` 배열 속성에서 **명령 줄 인수**를 얻을 수 있다.<br/>

-   `test/processArgs-Test.ts`

```typescript
process.argv.forEach((val: string, index: number) => {
    console.log(index + ": " + val);
});
```

-   `test/processArgs-Test.ts` 실행결과

```shell
0: C:\...\nodejs\node_modules\ts-node\dist\bin.js
1: C:\...\test\processArgs-test.ts
2: data/fake.csv
3: 100000
```

위와 같이 `data/fake.csv`와 `100000` 값은 `index`가 `2`와 `3`일 때 얻어지는 것을 볼 수 있다.<br/>
이 내용을 바탕으로 `utils` 폴더에 `getFileNameAndNumber.ts` 함수를 작성한다.<br/>

-   `utils/getFileNameAndNumber.ts`

```typescript
export type FileNameAndNumber = [string, number];

export const getFileNameAndNumber = (
    defaultFileName: string,
    defaultNumberOfFakeData: number
): FileNameAndNumber => {
    const [bin, node, filename, numberOfFakeData] = process.argv;
    return [
        filename || defaultFileName,
        numberOfFakeData
            ? parseInt(numberOfFakeData, 10)
            : defaultNumberOfFakeData,
    ];
};
```

아래의 테스트 코드를 사용해 작성한 `getFileNameAndNumber` 함수를 테스트할 수 있다.<br/>

-   `test/getFileNameAndNumber-Test.ts`

```typescript
import { getFileNameAndNumber } from "../utils/getFileNameAndNumber";

const [fileName, numberOfFakeItems] = getFileNameAndNumber(
    "data/fake.csv",
    100000
);
console.log(fileName, numberOfFakeItems); // data/fake.csv 100000
```

위와 같이 **명령 줄 인수**로 넘긴 파일 이름과 숫자를 얻을 수 있다.<br/>

### 파일 처리 비동기 함수를 Promise로 구현하기

#### (1) fs.access API로 디렉터리나 파일 확인하기

`fs.access` 함수를 사용하면 파일이나 디렉터리가 있는지 없는지 확인할 수 있다.<br/>
아래 코드는 파일이나 디렉터리가 있는지 확인하는 기능을 `Promise` 형태로 구현했다.<br/>

-   `fileApi/fileExists.ts`

```typescript
import * as fs from "fs";

export const fileExists = (filePath: string): Promise<boolean> =>
    new Promise((resolve) =>
        fs.access(filePath, (error) => resolve(error ? false : true))
    );
```

`fs.access` 함수를 사용해 파일이나 디렉터리가 있는지 확인해 `Promise`를 반환한다.<br/>
아래의 테스트 코드로 작성한 `fileExists` 함수를 테스트할 수 있다.<br/>

-   `test/fileExists-Test.ts`

```typescript
import { fileExists } from "../fileApi/fileExists";

const exists = async (filePath) => {
    const result = await fileExists(filePath);
    console.log(`${filePath} ${result ? "exists" : "not exists"}`);
};

exists("./package.json"); // ./package.json exists
exists("./package"); // ./package not exists
```

위와 같이 파일이나 디렉터리의 존재여부를 확인할 수 있는 것을 볼 수 있다.<br/>

#### (2) mkdirp 패키지로 디렉터리 생성 함수 만들기

`node.js`는 `mkdir`이라는 API를 제공한다.<br/>
하지만 `mkdir`은 `./src/data/today`처럼 여러 경로의 디렉터리를 한번에 만들지는 못한다.<br/>
반면에 `mkdirp` 패키지는 `mkdir -p` 처럼 한번에 여러 디렉터리를 만드는 기능을 제공한다.<br/>
아래 코드는 디렉터리가 있는지를 판단해 없을 때만 `mkdirp` 함수로 디렉터리를 생성한다.<br/>

-   `fileApi/mkdir.ts`

```typescript
import mkdirp from "mkdirp";
import { fileExists } from "./fileExists";

export const mkdir = (dirname: string): Promise<string> =>
    new Promise(async (resolve, reject) => {
        const alreadyExists = await fileExists(dirname);
        alreadyExists
            ? resolve(dirname)
            : mkdirp(dirname, (error) =>
                  error ? reject(error) : resolve(dirname)
              );
    });
```

아래의 테스트 코드로 동작을 확인할 수 있다.<br/>

-   `test/mkdir-Test.ts`

```typescript
import { mkdir } from "../fileApi/mkdir";

const makeDataDir = async (dirname: string) => {
    let result = await mkdir(dirname);
    console.log(`'${result}' dir created`);
};

makeDataDir("./data/today"); // './data/today' dir created
```

위의 코드를 실행하면 프로젝트 경로에 `data` 폴더와 그 안에 `today` 폴더가 생긴 것을 볼 수 있다.<br/>

#### (3) rimraf 패키지로 디렉터리 삭제 함수 만들기

`node.js`는 폴더를 삭제하는 `fs.rmdir`이라는 함수를 제공한다.<br/>
`fs.rmdir` 함수는 비어 있지 않은 디렉터르는 삭제하지 못하는 문제점이 있다.<br/>
`rimraf` 패키지를 이용하면 비어 있지 않은 디렉터리 또한 삭제할 수 있다.<br/>
아래 코드는 `rimraf` 함수로 디렉터리 삭제 함수 `rmdir`을 구현한다.<br/>

-   `fileApi/rmdir.ts`

```typescript
import rimraf from "rimraf";
import { fileExists } from "./fileExists";

export const rmdir = (dirname: string): Promise<string> =>
    new Promise(async (resolve, reject) => {
        const alreadyExists = await fileExists(dirname);
        !alreadyExists
            ? resolve(dirname)
            : rimraf(dirname, (error) =>
                  error ? reject(error) : resolve(dirname)
              );
    });
```

아래의 테스트 코드로 동작을 확인할 수 있다.<br/>

-   `test/rmdir-Test.ts`

```typescript
import { rmdir } from "../fileApi/rmdir";

const deleteDataDir = async (dir) => {
    const result = await rmdir(dir);
    console.log(`'${result}' dir deleted.`);
};

deleteDataDir("./data/today"); // './data/today' dir deleted.
```

위의 코드를 실행하면 프로젝트 경로에 `today` 폴더가 삭제 된 것을 볼 수 있다.<br/>

#### (4) fs.writeFile API로 파일 생성하기

`node.js` 환경에서 파일의 데이터를 읽거나 쓸 때는 대부분 텍스트 데이터를 대상으로 한다.<br/>
텍스트 데이터를 처리할 때에는 유니코드로 데이터를 처리해야한다.<br/>
유니코드 텍스트 데이터를 처리할 때 `fs.writeFile` API는 아래와 같이 사용할 수 있다.<br/>

```typescript
import * as fs from "fs";

fs.writeFile(filepath, data, "utf8", callback);
```

아래 코드는 `fs.writeFile`을 `Promise`를 반환하도록 구현한 함수다.<br/>

-   `fileApi/writeFile.ts`

```typescript
import * as fs from "fs";

export const writeFile = (filename: string, data: any): Promise<any> =>
    new Promise((resolve, reject) => {
        fs.writeFile(filename, data, "utf8", (error: Error) => {
            error ? reject(error) : resolve(data);
        });
    });
```

아래의 테스트 코드는 `./data` 폴더를 생성하고 `hello.txt`와 `test.json` 파일을 작성하는 예시다.<br/>

-   `test/writeFile-Test.ts`

```typescript
import { writeFile } from "../fileApi/writeFile";
import { mkdir } from "../fileApi/mkdir";

const writeTest = async (filename: string, data: any) => {
    const result = await writeFile(filename, data);
    console.log(`wrtie ${result} to ${filename}`);
};

mkdir("./data")
    .then((s) => writeTest("./data/hello.txt", "hello world"))
    .then((s) =>
        writeTest(
            "./data/test.json",
            JSON.stringify({ name: "Jack", age: 32 }, null, 2)
        )
    )
    .catch((e: Error) => console.log(e.message));

// wrtie hello world to ./data/hello.txt
// wrtie {
//   "name": "Jack",
//   "age": 32
// } to ./data/test.json
```

`hello.txt`와 `test.json` 파일이 생성되고 내용이 작성되어있는 것을 볼 수 있다.<br/>
객체를 문자열로 바꾸는 기능의 기본적인 사용법은 `JSON.stringify(object)`과 같이 사용한다.<br/>
`JSON.stringify(object, null, 2)`으로 사용해 줄바꿈과 들여쓰기가 되어있는 데이터를 볼 수 있다.<br/>
여기에서 3번째 인자로 넘겨진 `2`는 들여쓰기를 위한 공백 문자의 개수를 의미한다.<br/>

#### (5) fs.readFile API로 파일 내용 읽기

파일에 담긴 데이터를 읽을 때는 `fs.readFile` API를 사용한다.<br/>
파일에 담긴 데이터는 텍스트 포맷과 바이너리 포맷으로 읽을 수 있다.<br/>
보통 `node.js` 환경에서 파일의 데이터를 읽거나 쓸 때는 `utf8` 포맷을 사용한다.<br/>
`fs.readFile` API를 이용해 유니코드 텍스트를 읽을 때는 아래와 같이 사용한다.<br/>

```typescript
import * as fs from "fs";

fs.readFile(filepath, "utf8", callback);
```

아래 코드는 `fs.readFile`을 `Promise`를 반환하도록 구현한 함수다.<br/>

-   `fileApi/readFile.ts`

```typescript
import * as fs from "fs";

export const readFile = (filename: string): Promise<any> =>
    new Promise<any>((resolve, reject) => {
        fs.readFile(filename, "utf8", (error: Error, data: any) => {
            error ? reject(error) : resolve(data);
        });
    });
```

아래의 테스트 코드는`hello.txt`와 `test.json` 파일을 `readFile` 함수로 읽는 예시다.<br/>

-   `test/readFile-Test.ts`

```typescript
import { readFile } from "../fileApi/readFile";

const readTest = async (filename: string) => {
    const result = await readFile(filename);
    console.log(`read '${result}' from ${filename} file.`);
};

readTest("./data/hello.txt")
    .then((s) => readTest("./data/test.json"))
    .catch((e: Error) => console.log(e.message));

// read 'hello world' from ./data/hello.txt file.
// read '{
// "name": "Jack",
//     "age": 32
// }' from ./data/test.json file.
```

위와 같이 `writeFile`로 생성한 두 개의 파일들을 잘 읽어오는 것을 확인할 수 있다.<br/>

#### (6) fs.appendFile API로 파일 내용 추가하기

`fs.writeFile`은 파일이 이미 존재할 때는 기존 파일 내용을 모두 지우고 새로운 데이터를 쓴다.<br/>
기존 내용을 끝에 새로운 데이터를 삽입하고자 한다면 `fs.appendFile`을 사용해야 한다.<br/>
아래 코드는 `fs.appendFile`을 `Promise`를 반환하도록 구현한 함수다.<br/>

-   `fileApi/appendFile.ts`

```typescript
import * as fs from "fs";

export const appendFile = (filename: string, data: any): Promise<any> =>
    new Promise((resolve, reject) => {
        fs.appendFile(filename, data, "utf8", (error: Error) => {
            error ? reject(error) : resolve(data);
        });
    });
```

아래 테스트 코드는 `./data/hello.txt`에 `"Hi, there!"`이라는 문자열을 추가한다.<br/>

-   `test/appendFile-Test.ts`

```typescript
import { appendFile } from "../fileApi/appendFile";
import { mkdir } from "../fileApi/mkdir";

const appendTest = async (filename: string, data: any) => {
    const result = await appendFile(filename, data);
    console.log(`append ${result} to ${filename}`);
};

mkdir("./data")
    .then((s) => appendTest("./data/hello.txt", "Hi, there!"))
    .catch((e: Error) => console.log(e.message));

// append Hi, there! to ./data/hello.txt
```

`hello.txt`를 확인해보면 `hello worldHi, there!` 같이 데이터를 유지하며 추가된 것을 볼 수 있다.<br/>

#### (7) fs.unlink API로 파일 삭제하기

`node.js` 환경에서 파일을 삭제할 때는 `fs.unlink` API를 사용한다.<br/>
아래의 `deleteFile` 함수는 파일이 존재하는지 판별해 존재할 때 파일을 삭제하는 기능을 한다.<br/>

-   `fileApi/deleteFile.ts`

```typescript
import * as fs from "fs";
import { fileExists } from "./fileExists";

export const deleteFile = (filename: string): Promise<string> =>
    new Promise<any>(async (resolve, reject) => {
        const alreadyExists = await fileExists(filename);
        !alreadyExists
            ? resolve(filename)
            : fs.unlink(filename, (error) =>
                  error ? reject(error) : resolve(filename)
              );
    });
```

아래 테스트 코드는 `./data` 폴더에 있는 데이터와 `./data` 폴더를 삭제한다.<br/>

-   `test/deleteFile-Test.ts`

```typescript
import { deleteFile } from "../fileApi/deleteFile";
import { rmdir } from "../fileApi/rmdir";

const deleteTest = async (filename: string) => {
    const result = await deleteFile(filename);
    console.log(`delete ${result} file.`);
};

Promise.all([deleteTest("./data/hello.txt"), deleteTest("./data/test.json")])
    .then((s) => rmdir("./data"))
    .then((dirname) => console.log(`delete ${dirname} dir.`))
    .catch((e: Error) => console.log(e.message));

//delete ./data/test.json file.
//delete ./data/hello.txt file.
//delete ./data dir.
```

위의 코드를 실행시키면 `./data` 폴더 내부의 파일과 `./data`폴더가 삭제되는 것을 볼 수 있다.<br/>

#### (8) fileApi/index.ts 파일 만들기

`src/fileApi` 폴더에 `index.ts` 파일을 생성하고 아래의 내용을 작성한다.<br/>

-   `fileApi/index.ts`

```typescript
import { mkdir } from "./mkdir";
import { rmdir } from "./rmdir";
import { readFile } from "./readFile";
import { writeFile } from "./writeFile";
import { fileExists } from "./fileExists";
import { appendFile } from "./appendFile";
import { deleteFile } from "./deleteFile";

export {
    fileExists,
    mkdir,
    rmdir,
    writeFile,
    readFile,
    appendFile,
    deleteFile,
};
```

`export`를 이용해 다른 파일에서 구현된 함수들을 모두 다시 내보낸다.<br/>
앞으로 `fileApi` 폴더안에 구현된 함수들은 `./src/fileApi`에서 가져와 사용할 수 있다.<br/>

### 그럴듯한 가짜 데이터 만들기

앞과 동일하게 `chance` 패키지를 사용해 그럴듯한 가짜 데이터를 생성할 수 있다.<br/>
`IFake`라는 이름으로 프로필 정보를 갖는 인터페이스를 아래와 같이 구현한다.<br/>

-   `fake/IFake.ts`

```typescript
export interface IFake {
    name: string;
    email: string;
    sentence: string;
    profession: string;
    birthday: Date;
}
```

`chance` 패키지를 이용해 `IFake` 인터페이스 형태의 데이터를 생성하는 함수를 작성한다.<br/>

-   `fake/makeFakeData.ts`

```typescript
import Chance from "chance";
import { IFake } from "./IFake";

const c = new Chance();

export const makeFakeData = (): IFake => ({
    name: c.name(),
    email: c.email(),
    profession: c.profession(),
    birthday: c.birthday(),
    sentence: c.sentence(),
});

export { IFake };
```

아래 코드로 작성한 `makeFakeData` 함수를 테스트할 수 있다.<br/>

-   `test/makeFakeData-Test.ts`

```typescript
import { makeFakeData, IFake } from "../fake/makeFakeData";

const fakeData: IFake = makeFakeData();
console.log(fakeData);
// {
//   name: 'Wayne Jenkins',
//   email: 'dair@di.bh',
//   profession: 'Payroll Specialist',
//   birthday: 1992-12-07T17:00:56.753Z,
//   sentence: 'Lo udtizro lezirezu uh opeweten uki eve bob atrepij polur zuwu hoowuse vi focbus.'
// }
```

위와 같이 `IFake` 인터페이스 속성을 갖는 가짜 데이터가 생성된 것을 볼 수 있다.<br/>

### Object.keys와 Object.values 함수 사용하기

CSV 파일을 만들기 위해서는 객체의 속성과 값을 분리해야 한다.<br/>
이 때 사용할 수 있는 함수는 `Object.keys`와 `Object.values` 함수다.<br/>
아래의 코드는 이 두 함수를 사용해 객체의 속성 이름과 속성 값으로 구성된 배열을 반환한다.<br/>

-   `test/keys-values-Test.ts`

```typescript
import { IFake, makeFakeData } from "../fake/makeFakeData";

const data: IFake = makeFakeData();

const keys = Object.keys(data);
console.log("keys :", keys);
// keys : [ 'name', 'email', 'profession', 'birthday', 'sentence' ]

const values = Object.values(data);
console.log("values :", values);
// values : [
//   'Harriet Carpenter',
//   'jumibe@mono.tf',
//   'Security Director',
//   1968-04-06T22:39:20.764Z,
//   'Muz uw veglivun ho metbifi ta su vefniiw bif wolawi lervimba weogjo al aluko vudatzur.'
// ]
```

위와 같이 `IFake` 타입 객체의 속성 이름과 값이 분리되어 반환되는 것을 볼 수 있다.<br/>

### CSV 파일 만들기

가짜 데이터를 여러 개 생성해 CSV 파일에 쓰기위해 아래의 `range` 함수를 구현한다.<br/>

-   `utils/range.ts`

```typescript
export function* range(max: number, min: number = 0) {
    while (min < max) {
        yield min++;
    }
}
```

이제 앞에서 구현한 함수들을 사용해 `numberOfItems` 만큼 `IFake` 객체를 생성한다.<br/>
그 후 속성명과 속성값의 배열을 각각 추출해 `filename` 파일을 생성할 수 있다.<br/>

-   `fake/writeCsvFormatFakeData.ts`

```typescript
import * as path from "path";
import { IFake, makeFakeData } from "./makeFakeData";
import { mkdir, writeFile, appendFile } from "../fileApi";
import { range } from "../utils/range";

export const writeCsvFormatFakeData = async (
    filename: string,
    numberOfItems: number
): Promise<string> => {
    const dirname = path.dirname(filename),
        comma = ",",
        newLine = "\n";
    await mkdir(dirname);

    for (let n of range(numberOfItems)) {
        const fake: IFake = makeFakeData();

        if (n == 0) {
            const keys = Object.keys(fake).join(comma);
            await writeFile(filename, keys);
        }

        const values = Object.values(fake).join(comma);
        await appendFile(filename, newLine + values);
    }

    return `write ${numberOfItems} items to ${filename} file.`;
};
```

CSV 파일의 첫 줄은 객체의 속성 이름을 쉼표로 구분해서 작성해야 한다.<br/>
따라서 `Object.keys(fake).join(comma)` 같이 속성 이름 배열에 `join` 메서드를 사용해 구현하였다.<br/>
이후에는 `Object.values(fake).join(comma)` 같이 속성 값 배열을 `join` 메서드를 사용해 추가한다.<br/>
지금까지 구현한 파일들을 사용하기 쉽게 `src/fake` 폴더에 `index.ts` 파일을 작성한다.<br/>

-   `fake/index.ts`

```typescript
import { IFake, makeFakeData } from "./makeFakeData";
import { writeCsvFormatFakeData } from "./writeCsvFormatFakeData";

export { IFake, makeFakeData, writeCsvFormatFakeData };
```

위와 같이 작성함으로써 `fake` 폴더 안에 구현한 기능들을 `src/fake` 경로에서 가져올 수 있다.<br/>

### 데이터를 CSV 파일에 쓰기

### zip 함수 만들기

### 생성기 코드를 구현할 때 주의할 점

### CSV 파일 데이터 읽기

[[🔝위로가기]](#12장-프로젝트-실습)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 12-2 몽고DB에 데이터 저장하기

[[🔝위로가기]](#12장-프로젝트-실습)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 12-3 익스프레스로 API 서버 만들기

[[🔝위로가기]](#12장-프로젝트-실습)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)

## 12-4 리액트와 부트스트랩으로 프론트엔드 웹 만들기

[[🔝위로가기]](#12장-프로젝트-실습)&nbsp; / &nbsp;[[🔙뒤로가기]](https://github.com/alstn2468/DoIt_Typescript_Programming/blob/master/README.md)
